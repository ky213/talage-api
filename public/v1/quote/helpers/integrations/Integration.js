/**
 * Defines a insurer integration
 */

'use strict';

const crypt = require('../helpers/crypt.js');
const file = require('../helpers/file.js');
const htmlentities = require('html-entities').Html5Entities;
const https = require('https');
const moment = require('moment');
const util = require('util');
const{'v4': uuidv4} = require('uuid');
const xmlToObj = require('xml2js').parseString;
const serverHelper = require('../../../../../server.js');

module.exports = class Integration{

	/**
	 * Constructor for each integration
	 *
	 * @param {Application} app - An object containing all of the application information
	 * @param {object} insurer - An object containing all of the insurer information
	 * @param {object} policy - The data related to the current policy
	 * @returns {void}
	 */
	constructor(app, insurer, policy){

		this.app = app;
		this.industry_code = {};
		this.insurer = insurer;
		this.insurer_wc_codes = {};
		this.grouped_activity_codes = [];
		this.limits = {};
		this.log = '';
		this.number = '';
		this.policy = policy;
		this.questions = {};
		this.question_identifiers = {};
		this.question_details = {};
		this.request_id = '';
		this.seconds = 0;
		this.universal_questions = [];
		this.writer = '';

		// These are set in our insurer integration
		this.possible_api_responses = {};

		// These are generated by our insurer integration
		this.amount = 0;
		this.quote_letter = {};
		this.reasons = [];

		// Process payroll caps for Nevada
		const nv_payroll_cap = 36000;
		if(this.app.business){
			if(app.business.primary_territory === 'NV'){

				// Loop through each location
				app.business.locations.forEach(function(location, location_index){

					// Total the employees
					const total_employees = location.full_time_employees + location.part_time_employees;

					// Loop through each class code
					location.activity_codes.forEach(function(code, code_index){

						// If the payroll is over the cap, set it to the cap
						if(code.payroll / total_employees > nv_payroll_cap){
							app.business.locations[location_index].activity_codes[code_index].payroll = nv_payroll_cap * total_employees;
						}
					});
				});
			}
		}
	}

	/**
	 * An entry point for binding a quote that conducts some necessary pre-processing before calling the insurer_bind function.
	 *
	 * @returns {Promise.<string, ServerError>} A promise that returns a string containing bind result (either 'Bound' or 'Referred') if resolved, or a ServerError if rejected
	 */
	bind(){
		log.info(`${this.insurer.name} ${this.policy.type} Bind Started (mode: ${this.insurer.test_mode ? 'test' : 'live'})`);
		return new Promise(async(fulfill, reject) => {

			// Make sure the _bind() function exists
			if(typeof this._bind === 'undefined'){
				log.warn(`${this.insurer} ${this.policy.type} integration does not support binding quotes`);
				reject(serverHelper.NotFoundError('Insurer integration does not support binding quotes at this time'));
				return;
			}

			// Check for an outage
			if(this.insurer.outage){
				log.warn(`${this.insurer} is currently unavailable due to scheduled maintenance`);
				reject(serverHelper.ServiceUnavailableError('Insurer is currently unavailable due to scheduled maintance'));
				return;
			}

			// Run the insurer's bind function
			await this._bind().then(function(result){
				fulfill(result);
			}).catch(function(error){
				reject(error);
			});
		});
	}

	/**
	 * Returns an object that includes Claims information based on policy years for up to the past 5 years
	 *
	 * @returns {object} - Claims information lumped together by policy year
	 */
	claims_to_policy_years(){
		const claims = {};
		this.policy.claims.forEach((claim) => {

			// Determine the policy year (year 1 is within effective date - 1 year, year 2 within 2 years, etc.)
			let effective_date = this.policy.effective_date.clone();
			let year = 0;
			for(let i = 1; i <= 5; i++){
				effective_date = effective_date.subtract(1, 'years');
				if(claim.date.isAfter(effective_date)){
					year = i;
					break;
				}
			}

			// Make sure the claim was within the last 5 years
			if(!year){
				return;
			}

			// If claims information was not already started for this year, add it
			if(!Object.prototype.hasOwnProperty.call(claims, year)){
				const c = {};
				c.amount_paid = 0;
				c.amount_reserved = 0;
				c.count = 0;
				c.effective_date = effective_date;
				c.expiration_date = effective_date.clone().add(1, 'years');
				c.missed_time = 0;
				claims[year] = c;
			}

			// Process this claim
			if(claim.open){
				claims[year].amount_reserved += claim.amount;
			}else{
				claims[year].amount_paid += claim.amount;
			}
			claims[year].count++;
			if(claim.missed_time){
				claims[year].missed_time++;
			}
		});

		return claims;
	}

	/**
	 * Uses the activity codes from a single location combined with the insurer's specific NCCI codes to detect and combine any duplicates.
	 *
	 * @param {object} location - A single Location object
	 * @returns {object} - The activity codes from within the location with any duplicates combined as code -> payroll pairs
	 */
	combineLocationActivityCodes(location){
		const returnCodes = {};
		location.activity_codes.forEach((activityCode) => {

			// Get the insurer's code for this activity
			const insurerCode = this.insurer_wc_codes[location.territory + activityCode.id];

			// Check if this code was already found
			if(Object.prototype.hasOwnProperty.call(returnCodes, insurerCode)){
				// Combine the payroll
				returnCodes[insurerCode] += activityCode.payroll;
				return;
			}

			// This is a new one
			returnCodes[insurerCode] = activityCode.payroll;
		});

		return returnCodes;
	}

	/**
	 * Determines the governing activity code for an application and returns the result.
	 * The governing class code is determined by taking the activity code with the highest payroll. If there are two, the first code is used.
	 * If the highest payroll code is our clerical code, it is ignored and the next highest is taken.
	 *
	 * @returns {object} - An ActivityCode object
	 */
	determine_governing_activity_code(){
		// Group the activity codes
		this.group_activity_codes();

		// If there are not at least 2 activity codes, just return what we have
		if(this.grouped_activity_codes.length < 2){
			return this.grouped_activity_codes;
		}

		// Sort the activity codes based on payroll
		this.grouped_activity_codes.sort(function compare(a, b){
			if(a.payroll > b.payroll){
				return -1;
			}
			if(a.payroll < b.payroll){
				return 1;
			}
			return 0;
		});

		// Check if the highest payroll is our clerical code
		if(this.grouped_activity_codes[0].id === 2869){
			// The highest payroll was clerical, reutrn the next highest instead
			return this.grouped_activity_codes[1];
		}
		// It wasn't clerical, return the highest payroll
		return this.grouped_activity_codes[0];
	}

	/**
	 * Determines the proper answer to send to the insurer based on the question type. Return false if the question should be skipped.
	 *
	 * @param {object} question - A question object
	 * @param {boolean} required - Whether or not this question is required by the insurer
	 * @returns {mixed} - The answer to send to the insurer, or false if the question should be omitted
	 */
	determine_question_answer(question, required){
		let answer = false;

		// Default required
		required = required ? required : false;

		// If this question has a parent that belongs to the same insurer, this question is not required, and the parent question was answered 'NO', skip this question
		if(question.parent && Object.prototype.hasOwnProperty.call(this.questions, question.parent) && !required && !this.questions[question.parent].get_answer_as_boolean()){
			return false;
		}

		// If this question has a parent that belongs to a different insurer it should have a default
		if(question.parent && !Object.prototype.hasOwnProperty.call(this.questions, question.parent) && question.answer_id === 0 && question.answer === null){
			log.error(`Question ${question.id} is missing a default answer. Defaulted to 'No' for this application. May cause quoting inaccuracies!`);
			return 'No';
		}

		// If the answer is based on a database entry, process it differently than text based answers
		if(question.type === 'Yes/No' || question.type === 'Checkbox' || question.type === 'Select List'){

			// Determine the answer based on the Answer ID stored in our database
			if(!Object.prototype.hasOwnProperty.call(question.possible_answers, question.answer_id)){
				// This shouldn't have happened, throw an error
				log.error(`${this.insurer.name} ${this.policy.type} encountered an answer to a question that is not possible. This should have been caught in the validation stage.`);
				log.verbose('The question is as follows:');
				log.verbose(util.inspect(question, false, null));
				throw new Error(`${this.insurer.name} ${this.policy.type} encountered an answer to a question that is not possible`);
			}

			answer = question.possible_answers[question.answer_id].answer;
		}else{
			// This is a fill-in-the-blank style question, simply send what the user gave us
			answer = question.answer;
		}

		return answer;
	}

	/**
	 * Retrieves the relationship between questions and activity codes
	 *
	 * @returns {Promise.<object, Error>} A promise that returns an object indexed on territory + activity code (e.g. AZ908252) each with an array of corresponding question ideas if resolved, or an Error if rejected
	 */
	get_activity_codes_to_questions_relationships(){
		return new Promise(async(fulfill, reject) => {

			// Only proceed if we have activity codes
			if(!this.insurer_wc_codes){
				reject(new Error('No activity codes'));
				return;
			}

			// Loop over every location and build the WHERE clause of our query
			const where_chunks = [];
			this.app.business.locations.forEach((location) => {
				// And then every activity code in a location
				location.activity_codes.forEach((activity_code) => {
					where_chunks.push(`(inc.\`code\` = '${this.insurer_wc_codes[location.territory + activity_code.id].substring(0, 4)}' AND inc.sub = '${this.insurer_wc_codes[location.territory + activity_code.id].substring(4, 6)}' AND inc.territory = '${location.territory}')`);
				});
			});

			// Build the SQL query
			const sql = `
				SELECT inc.territory, CONCAT(inc.\`code\`, inc.sub) AS class_code, GROUP_CONCAT(incq.question) AS questions
				FROM clw_talage_insurer_ncci_code_questions AS incq
				LEFT JOIN clw_talage_insurer_ncci_codes AS inc ON inc.id = incq.ncci_code AND inc.insurer = ${this.insurer.id}
				LEFT JOIN clw_talage_questions AS q ON incq.question = q.id
				WHERE q.state = 1 AND (${where_chunks.join(' OR ')}) GROUP BY inc.territory, class_code;
			`;
			const results = await db.query(sql).catch(function(error){
				reject(error);
			});

			// Convert this into an object for easy reference
			const relationships = {};
			if(results){
				results.forEach((result) => {
					relationships[result.territory + result.class_code] = result.questions.split(',');
				});
			}

			// Return the result
			fulfill(relationships);
		});
	}

	/**
	 * Determines the best limits available from the carrier. If no limits are suitable, returns false.
	 *
	 * @param {array} carrierLimits - A list of limits supported by the carrier
	 * @returns {array|boolean} - An array containing limit values as integers, or false if none apply
	 */
	getBestLimits(carrierLimits){
		let higherLimit = false;

		// Take the requested limits and prepare them for processing
		const requestedLimits = this.getSplitLimits(this.policy.limits);

		// Loop through all supported limits
		carrierLimits.forEach((limitSet) => {

			// Split the limits up and prepare them for processing
			const limitSetParts = this.getSplitLimits(limitSet);

			// Check if the supported limits are higher than or equal to the requested limits
			if(limitSetParts[0] >= requestedLimits[0] && limitSetParts[1] >= requestedLimits[1] && limitSetParts[2] >= requestedLimits[2]){
				// Return the first result found
				higherLimit = higherLimit ? higherLimit : limitSetParts;
			}
		});
		return higherLimit;
	}

	/**
	 * Returns the key (property) of an object based on the value of that property
	 *
	 * @param {object} obj - The object to search
	 * @param {mixed} val - The value to find
	 * @returns {string} - The key that matches
	 */
	get_key_by_value(obj, val){
		return Object.keys(obj).find((key) => obj[key] === val);
	}

	/**
	 * Returns a description of the operations of the company based on the class codes they selected
	 *
	 * @returns {string} - The description of the business
	 */
	get_operation_description(){
		return `${this.app.business.name} is a(n) ${this.app.business.industry_code_description.replace('&', 'and')} company with operations primarily located in ${this.app.business.locations[0].city}, ${this.app.business.locations[0].territory}.`;
	}

	/**
	 * Gets the number of unique activity codes were included in this application
	 *
	 * @returns {int} - The number of activity codes
	 */
	get_num_activity_codes(){
		// Group the activity codes
		this.group_activity_codes();

		// Return the count
		return this.grouped_activity_codes.length;
	}

	/**
	 * Returns the number of claims that were within the number of years specified
	 *
	 * @param {int} number_of_years - The number of years of claims to total
	 * @returns {int} - the number of claims
	 */
	get_num_claims(number_of_years){

		// Get the claims data organized by year
		const claims_by_year = this.claims_to_policy_years();

		// Loop through each year of claims
		let num_claims = 0;
		for(const claim_year in claims_by_year){
			if(Object.prototype.hasOwnProperty.call(claims_by_year, claim_year)){
				if(claim_year <= number_of_years){
					num_claims += claims_by_year[claim_year].count;
				}
			}
		}

		// Return the result
		return num_claims;
	}

	/**
	 * Gets the details for each question for the current insurer. These details include the attributes, identifier, and whether or not the question is universal
	 *
	 * @returns {Promise.<object, Error>} A promise that returns an object containing objects indexed on the Talage Question ID with question information specific to this insurer if resolved, or an Error if rejected
	 */
	get_question_details(){
		return new Promise(async(fulfill, reject) => {
			// Build an array of question IDs to retrieve
			const question_ids = Object.keys(this.questions);

			if(question_ids.length > 0){
				const sql = `SELECT question, universal, identifier, attributes FROM #__insurer_questions WHERE insurer = ${this.insurer.id} AND question IN (${question_ids.join(',')});`;
				const results = await db.query(sql).catch(function(error){
					reject(error);
				});

				// Convert this into an object for easy reference
				const question_details = {};
				results.forEach((result) => {
					question_details[result.question] = {
						'attributes': result.attributes ? JSON.parse(result.attributes) : '',
						'identifier': result.identifier,
						'universal': result.universal
					};
					if(result.universal){
						this.universal_questions.push(result.question);
					}
				});

				// Return the mapping
				fulfill(question_details);
			}else{
				fulfill({});
			}
		});
	}

	/**
	 * Retrieves the question that matches the identifier specified, returns false if none
	 *
	 * @param {string} identifier - The insurer identifier for the question
	 * @returns {mixed} - question object on success, false otherwise
	 */
	get_question_by_identifier(identifier){
		// Loop through each question and check the identifier
		for(const question_id in this.questions){
			if(Object.prototype.hasOwnProperty.call(this.questions, question_id)){
				if(this.question_identifiers[question_id] === identifier){
					return this.questions[question_id];
				}
			}
		}
		return false;
	}

	/**
	 * Gets the identifiers for each question for the current insurer
	 *
	 * @returns {Promise.<object, Error>} A promise that returns an object containing question information if resolved, or an Error if rejected
	 */
	get_question_identifiers(){
		log.info('get_question_identifiers FUNCTION IS DEPRECATED AND WILL BE REMOVED. USE get_question_details() INSTEAD WHICH RETURNS MORE DATA IN ONE QUERY');
		return new Promise(async(fulfill, reject) => {
			// Build an array of question IDs to retrieve
			const question_ids = Object.keys(this.questions);

			if(question_ids.length > 0){
				const sql = `SELECT question, universal, identifier FROM #__insurer_questions WHERE insurer = ${this.insurer.id} AND question IN (${question_ids.join(',')});`;
				const results = await db.query(sql).catch(function(error){
					reject(error);
				});

				// Convert this into an object for easy reference
				const identifiers = {};
				results.forEach((result) => {
					identifiers[result.question] = result.identifier;
					if(result.universal){
						this.universal_questions.push(result.question);
					}
				});

				// Return the mapping
				fulfill(identifiers);
			}else{
				fulfill({});
			}
		});
	}

	/**
	 * Splits a limits string into an array and coverts the values to integers
	 *
	 * @param {string} limits - A limits string
	 * @returns {array} - An array of integers
	 */
	getSplitLimits(limits){
		return limits.split('/').map(function(val){
			return parseInt(val, 10);
		});
	}

	/**
	 * Returns the total incurred (paid + reserved) on claims that were within the number of years specified
	 *
	 * @param {int} number_of_years - The number of years of claims to total
	 * @returns {int} - the number of claims
	 */
	get_total_amount_incurred_on_claims(number_of_years){

		// Get the claims data organized by year
		const claims_by_year = this.claims_to_policy_years();

		// Loop through each year of claims
		let total_incurred = 0;
		for(const claim_year in claims_by_year){
			if(Object.prototype.hasOwnProperty.call(claims_by_year, claim_year)){
				if(claim_year <= number_of_years){
					total_incurred += claims_by_year[claim_year].amount_paid;
					total_incurred += claims_by_year[claim_year].amount_reserved;
				}
			}
		}

		// Return the result
		return total_incurred;
	}

	/**
	 * Returns the total number of employees associated with this application
	 *
	 * @returns {int} - The total number of employees as an integer
	 */
	get_total_employees(){
		let total = 0;
		this.app.business.locations.forEach(function(loc){
			total += loc.full_time_employees;
			total += loc.part_time_employees;
		});
		return total;
	}

	/**
	 * Returns the total number of full-time employees associated with this application
	 *
	 * @returns {int} - The total number of full-time employees as an integer
	 */
	get_total_full_time_employees(){
		let total = 0;
		this.app.business.locations.forEach(function(loc){
			total += loc.full_time_employees;
		});
		return total;
	}

	/**
	 * Returns the total number of part-time employees associated with this application
	 *
	 * @returns {int} - The total number of part-time employees as an integer
	 */
	get_total_part_time_employees(){
		let total = 0;
		this.app.business.locations.forEach(function(loc){
			total += loc.part_time_employees;
		});
		return total;
	}

	/**
	 * Returns the total payroll associated with this application
	 *
	 * @returns {int} - The total payroll as an integer
	 */
	get_total_payroll(){
		let total = 0;
		this.app.business.locations.forEach(function(loc){
			loc.activity_codes.forEach(function(wc_code){
				total += wc_code.payroll;
			});
		});
		return total;
	}

	/**
	 * Returns the total square footage of locations associated with this application
	 *
	 * @returns {int} - The total square footage as an integer
	 */
	get_total_square_footage(){
		let total = 0;
		this.app.business.locations.forEach(function(loc){
			total += loc.square_footage;
		});
		return total;
	}

	/**
	 * Returns the number of years this business has operated
	 *
	 * @returns {int} - The total number of years in business
	 */
	get_years_in_business(){
		return moment().diff(this.app.business.founded, 'years');
	}

	/**
	 * Returns the years since the last claim was filed. If claims were never filed, returns 999
	 *
	 * @returns {int} - The total number of years
	 */
	get_years_since_claim(){
		if(!this.policy.claims.length){
			return 999;
		}

		let years_ago = 999;
		this.policy.claims.forEach((claim) => {
			const num_years = moment().diff(claim.date, 'years');
			if(num_years < years_ago){
				years_ago = num_years;
			}
		});
		return years_ago;
	}

	/**
	 * Generates and returns a Version 4 UUID
	 * Note: Version 4 UUIDs are completely random where Version 5 are not.
	 *
	 * @returns {string} - A random 36 character UUID formatted as follows 1f16f5d4-629b-11e7-b786-54616c616765
	 */
	generate_uuid(){
		return uuidv4();
	}

	/**
	 * Finds every activity code in an application and groups them together, adding their payrolls. Stores the result locally for later use.
	 *
	 * @returns {object} - An object with keys that are activity code ids, and values that are combined payrolls.
	 */
	group_activity_codes(){
		// If this function has already run, simply return what we already determined
		if(this.grouped_activity_codes.length){
			return this.grouped_activity_codes;
		}

		// First, localize all activity codes
		const activity_codes = [];

		// Get codes from all locations
		this.app.business.locations.forEach((location) => {
			// Loop through each code in this location
			location.activity_codes.forEach((activity_code) => {
				// Check if we have aleady seen this code on another location
				let seen = false;
				activity_codes.forEach((code, index) => {
					if(activity_code.id === code.id){
						seen = true;

						// Comine the payrolls for this code
						activity_codes[index].payroll += activity_code.payroll;
					}
				});

				if(!seen){
					// This is a new code, add it to our list
					activity_codes.push(activity_code);
				}
			});
		});

		// Store the results locally for later use
		this.grouped_activity_codes = activity_codes;

		return activity_codes;
	}

	/**
	 * An entry point for getting quotes that conducts some necessary pre-processing before calling the insurer_quote function.
	 *
	 * @returns {Promise.<object, Error>} A promise that returns an object containing quote information if resolved, or an Error if rejected
	 */
	quote(){
		log.info(`${this.insurer.name} ${this.policy.type} Quote Started (mode: ${this.insurer.test_mode ? 'test' : 'live'})`);
		return new Promise(async(fulfill, reject) => {

			// Get the credentials ready for use
			this.password = await this.insurer.get_password();
			this.username = await this.insurer.get_username();

			// Make sure the insurer_quote() function exists
			if(typeof this._insurer_quote === 'undefined'){
				const error_message = 'Integration file must include the insurer_quote() function';
				log.error(error_message);
				this.reasons.push(error_message);
				fulfill(this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.'));
				return;
			}

			// Check for outage
			if(this.insurer.outage){
				const error_message = `${this.insurer.name} is currently unavailable`;
				this.reasons.push(error_message);
				fulfill(this.return_error('outage'));
				return;
			}

			// Check that all of the selected codes are supported by the insurer
			let are_codes_supported = null;
			switch(this.policy.type){
				case 'BOP':
				case 'GL':
					are_codes_supported = await this._insurer_supports_industry_codes();
					if(are_codes_supported !== true){
						fulfill(are_codes_supported);
						return;
					}
					break;
				case 'WC':
					// Check code support
					are_codes_supported = await this._insurer_supports_activity_codes();
					if(this.insurer.id === 10){
						// Acuity requires CGL for WC also
						are_codes_supported = are_codes_supported === true ? await this._insurer_supports_industry_codes() : are_codes_supported;
					}
					if(are_codes_supported !== true){
						fulfill(are_codes_supported);
						return;
					}
					break;
				default:
					log.error(`Unexpected policy type of ${this.policy.type} in Integration`);
					fulfill(this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.'));
					return;
			}

			// Localize the questions and restrict them to only ones that are applicable to this insurer and policy type
			for(const question_id in this.app.questions){
				if(Object.prototype.hasOwnProperty.call(this.app.questions, question_id)){
					const question = this.app.questions[question_id];
					if(question.insurers.includes(`${this.insurer.id}-${this.policy.type}`)){
						this.questions[question_id] = question;
					}
				}
			}

			// Get the insurer question identifiers
			let stop = false;
			this.question_details = await this.get_question_details().catch((error) => {
				const error_message = `${this.insurer.name} ${this.policy.type} is unable to get question details. ${error}`;
				log.error(error_message);
				this.reasons.push(error_message);
				reject(this.return_error('error', 'We have no idea what went wrong, but we\'re on it'));
				stop = true;
			});
			this.question_identifiers = await this.get_question_identifiers().catch((error) => {
				const error_message = `${this.insurer.name} ${this.policy.type} is unable to get question identifiers. ${error}`;
				log.error(error_message);
				this.reasons.push(error_message);
				reject(this.return_error('error', 'We have no idea what went wrong, but we\'re on it'));
				stop = true;
			});
			if(stop){
				return;
			}

			// Run the quote
			await this._insurer_quote().then(function(result){
				fulfill(result);
			}).catch(function(error){
				reject(error);
			});
		});
	}

	/**
	 * Records this quote in the database so we know it happened
	 *
	 * @param {int} amount - The amount of the quote
	 * @param {string} pkg - The package selected by the user
	 * @param {string} error - An error code
	 * @returns {mixed} - ID on success, error on error
	 */
	async record_quote(amount, pkg, error){
		const encrypted_log = await crypt.encrypt(this.log).catch(function(){
			log.error('Unable to encrypt log. Proceeding anyway.');
		});

		const columns = [
			'application',
			'insurer',
			'log',
			'policy_type',
			'seconds',
			'created'
		];
		const values = [
			this.app.id,
			this.insurer.id,
			encrypted_log ? encrypted_log : '',
			this.policy.type,
			this.seconds,
			moment().format('YYYY-MM-DD HH:mm:ss')
		];

		// Amount
		if(amount){
			columns.push('amount');
			values.push(amount);
		}

		// Number
		if(this.number){
			columns.push('number');
			values.push(this.number);
		}

		// Package
		if(pkg){
			for(let i = 0; i < this.insurer.packages.length; i++){
				if(this.insurer.packages[i].id === pkg){
					columns.push('package_type');
					values.push(this.insurer.packages[i].id);
					break;
				}
			}
		}

		// Request ID
		if(this.request_id){
			columns.push('request_id');
			values.push(this.request_id);
		}

		// Writer
		if(this.writer){
			columns.push('writer');
			values.push(this.writer);
		}

		// Error
		columns.push('api_result');
		if(error){
			values.push(error);
		}else{
			values.push('quoted');
		}

		// Reasons
		if(this.reasons.length > 0){
			columns.push('reasons');
			values.push(this.reasons.join(',').replace(/'/g, '\\\'').substring(0, 500));
		}

		// Quote Letter
		if(this.quote_letter && Object.prototype.hasOwnProperty.call(this.quote_letter, 'data') && this.quote_letter.data){

			// Generate a UUID to use as the file name
			const fileName = `${this.generate_uuid()}.pdf`;

			// Store the quote letter in our cloud storage
			await file.store(`secure/quote-letters/${fileName}`, this.quote_letter.data).then(function(result){
				if(result){
					// The file was successfully saved, store the file name in the database
					columns.push('quote_letter');
					values.push(fileName);
				}
			});
		}

		// Insert the quote record
		const quoteResult = await db.query(`INSERT INTO \`#__quotes\` (\`${columns.join('`,`')}\`) VALUES (${values.map(db.escape).join(',')});`).catch(function(err){
			return err;
		});
		const quoteID = quoteResult.insertId;

		// Insert the limit records
		if(Object.keys(this.limits).length){
			const limitValues = [];
			for(const limitId in this.limits){
				if(Object.prototype.hasOwnProperty.call(this.limits, limitId)){
					limitValues.push(`(${quoteID}, ${limitId}, ${this.limits[limitId]})`);
				}
			}
			db.query(`INSERT INTO \`#__quote_limits\` (\`quote\`, \`limit\`, \`amount\`) VALUES ${limitValues.join(',')};`).catch(function(err){
				log.error(err);
			});
		}

		return quoteID;
	}

	/**
	 * Generates and returns the proper structure for returning an error from an integration
	 *
	 * @param {string} type - The type of error
	 * @param {string} message - A user friendly description of the error
	 * @returns {object} - An error object
	 */
	async return_error(type, message){
		log.info(`${this.insurer.name} ${this.policy.type} ${type}`);

		// If there were reasons, make sure we write them to the log
		if(this.reasons.length > 0){
			this.reasons.forEach((reason) => {
				log.verbose(reason);
			});
		}

		// Record this quote
		const id = await this.record_quote(null, null, type);

		// Build and return a response
		return {
			'id': id,
			'insurer': {
				'id': this.insurer.id,
				'logo': `${process.env.SITE_URL}/${this.insurer.logo}`,
				'name': this.insurer.name,
				'rating': this.insurer.rating
			},
			'message': message,
			'policy_type': this.policy.type,
			'status': type.indexOf('autodeclined') === -1 ? type : 'declined'
		};
	}

	/**
	 * Generates and returns the proper structure for returning an indication from an integration
	 *
	 * @param {int} amount - The amount of the indication as a whole number
	 * @returns {object} - An object containing the indication information
	 */
	async return_indication(amount){
		// Start building the quote
		const quote = {};
		quote.amount = amount;
		quote.id = 0;
		quote.instant_buy = false;
		quote.policy_type = this.policy.type;
		if(this.quote_letter && Object.prototype.hasOwnProperty.call(this.quote_letter, 'data') && this.quote_letter.data){
			quote.letter = this.quote_letter.data;
		}

		// Insurer info
		quote.insurer = {};
		quote.insurer.id = this.insurer.id;
		quote.insurer.logo = `${process.env.SITE_URL}/${this.insurer.logo}`;
		quote.insurer.name = this.insurer.name;
		quote.insurer.rating = this.insurer.rating;

		// Limits
		quote.limits = await this.returnLimits();

		// Record the quote
		quote.id = await this.record_quote(amount, null, 'referred_with_price');

		// Payment options
		if(this.insurer.payment_options.length){
			quote.payment_options = [];
			this.insurer.payment_options.forEach((payment_option) => {
				if(amount > payment_option.threshold){
					quote.payment_options.push({
						'description': payment_option.description,
						'id': payment_option.id,
						'name': payment_option.name
					});
				}
			});
		}

		return quote;
	}

	/**
	 * Returns an object of the limits for this policy with the propery as the limit description and the value as the amount
	 *
	 * @returns {object} - The limit information
	 */
	async returnLimits(){
		const rtn = {};

		// If there is no limits data, just return an empty object
		if(!Object.keys(this.limits).length){
			return rtn;
		}

		// Get the limit descriptions from the database
		const result = await db.query(`SELECT * FROM \`#__limits\` WHERE \`id\` IN (${Object.keys(this.limits).join(',')}) ORDER BY description ASC;`).catch(function(err){
			return err;
		});

		// Loop through the results and build the response
		result.forEach((limitInfo) => {
			rtn[limitInfo.description] = this.limits[limitInfo.id];
		});

		return rtn;
	}

	/**
	 * Determines which response should be sent, and sends it. This should be called by every insurer integration.
	 *
	 * @param {string} result - The result of the integration. Must be 'declined', 'quoted', 'referred', or 'referred_with_price'
	 * @returns {mixed} - An object containing the response to be sent to the user on success, false on failure
	 */
	return_result(result){
		// Determine the log messages to show
		const log_messages = {
			'autodeclined': 'System Autodeclined',
			'declined': 'Application Declined',
			'error': 'Integration Error',
			'outage': 'Insurer System Outage',
			'quoted': 'Quote Recieved',
			'referred': 'Application Referred',
			'referred_with_price': 'Application Referred With Price'
		};

		// Make sure we have a result
		if(!result){
			const error_message = `${this.insurer.name} ${this.policy.type} Integration Error: Missing argument for return_result(). Must pass in a valid value for result.`;
			log.error(error_message);
			this.reasons.push(error_message);
			return this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.');
		}

		// Make sure the result is one of the ones we are expecting
		if(!Object.keys(log_messages).includes(result)){

			// If result is a possible API result from an integration, convert it to the Talage equivalent
			if(Object.keys(this.possible_api_responses).includes(result)){
				result = this.possible_api_responses[result];
			}else{
				const error_message = `${this.insurer.name} ${this.policy.type} Integration Error: Invalid value of '${result}' for result passed to return_result(). Result not specified in the insurer integration.`;
				log.error(error_message);
				this.reasons.push(error_message);
				return this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.');
			}

			// Double check: Is the result now what we are expecting
			if(!Object.keys(log_messages).includes(result)){
				const error_message = `${this.insurer.name} ${this.policy.type} Integration Error: Invalid value of '${result}' for result passed to return_result(). Must be a valid value as defined in return_result().`;
				log.error(error_message);
				this.reasons.push(error_message);
				return this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.');
			}
		}

		// Check if this was referred, but a price was still provided, and if so, update the status
		if((result === 'referred' || this.indication) && this.amount){
			result = 'referred_with_price';
		}

		// If this was quoted, make sure we have an amount
		if((result === 'quoted' || result === 'referred_with_price') && !this.amount){
			log.error(`${this.insurer.name} ${this.policy.type} Integration Error: Unable to find quote amount. Response structure may have changed.`);
			this.reasons.push(`${this.insurer.name} ${this.policy.type} Integration Error: Unable to find quote amount. Response structure may have changed.`);
			if(result === 'quoted'){
				result = 'error';
			}else{
				result = 'referred';
			}
		}

		// If this was quoted, make sure we have limits
		if((result === 'quoted' || result === 'referred_with_price') && !Object.keys(this.limits).length){
			log.error(`${this.insurer.name} ${this.policy.type} Integration Error: Unable to find limits. Response structure may have changed.`);
		}

		// Start the log message
		this.log += `--------======= ${log_messages[result]} =======--------<br><br>`;

		// Log the amount
		if(this.amount){
			this.log += `Quote: ${this.amount}<br>`;
		}

		// Log the reasons
		if(this.reasons.length > 0){
			this.log += `The insurer returned the following reasons for why they made this decision:<ul><li>${this.reasons.join('</li><li>')}</li></ul>`;
		}

		// Take the appropriate action
		switch(result){
			case 'autodeclined':
				return this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time');

			case 'declined':
				if(this.reasons){
					this.reasons.forEach(function(reason){
						log.verbose(reason);
					});
				}
				this.reasons.push('Declined by insurer');
				return this.return_error('declined', `${this.insurer.name} has declined to offer you coverage at this time`);

			case 'error':
				log.error(`${this.insurer.name} ${this.policy.type} Integration Encountered An Error`);
				if(this.reasons){
					this.reasons.forEach(function(reason){
						log.info(reason);
					});
				}
				return this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.');

			case 'outage':
				log.warn(`${this.insurer.name} ${this.policy.type} Experienced A System Outage At The Time of Quote`);
				if(this.reasons){
					this.reasons.forEach(function(reason){
						log.verbose(reason);
					});
				}
				return this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.');

			case 'quoted':
				log.info(`${this.insurer.name} ${this.policy.type} Returned Quote(s)`);
				return this.return_quote(this.amount);

			case 'referred':
				if(this.reasons){
					this.reasons.forEach(function(reason){
						log.verbose(reason);
					});
				}
				return this.return_error('referred', `${this.insurer.name} needs a little more time to make a decision`);

			case 'referred_with_price':
				log.info(`${this.insurer.name} ${this.policy.type} Referred To Underwriting, But Provided An Indication`);
				return this.return_indication(this.amount);

			default:

		}
	}

	/**
	 * Generates and returns the proper structure for returning a quote from an integration
	 *
	 * @param {int} amount - The amount of the quote as a whole number
	 * @param {string} pkg (optional) - The name of the applicable package, must match what is in our database
	 * @returns {object} - An object containing the quote information
	 */
	async return_quote(amount, pkg){
		// Start building the quote
		const quote = {};
		quote.amount = amount;
		quote.id = 0;
		quote.instant_buy = true;
		if(this.quote_letter && Object.prototype.hasOwnProperty.call(this.quote_letter, 'data') && this.quote_letter.data){
			quote.letter = this.quote_letter.data;
		}

		// Insurer info
		quote.insurer = {};
		quote.insurer.id = this.insurer.id;
		quote.insurer.logo = `${process.env.SITE_URL}/${this.insurer.logo}`;
		quote.insurer.name = this.insurer.name;
		quote.insurer.rating = this.insurer.rating;

		// Limits
		quote.limits = await this.returnLimits();

		// Package
		let package_id = null;
		if(typeof pkg !== 'undefined' && pkg){
			let package_found = false;
			for(let i = 0; i < this.insurer.packages.length; i++){
				if(this.insurer.packages[i].name === pkg){
					quote.package = {};
					package_id = this.insurer.packages[i].id;
					quote.package.description = this.insurer.packages[i].description;
					quote.package.name = this.insurer.packages[i].name;
					package_found = true;
					break;
				}
			}
			if(!package_found){
				log.warn(`Undefined package referenced for ${this.insurer.name} ${this.policy.type}`);
			}
		}

		// Record this Quote
		await this.record_quote(amount, package_id).then((id) => {
			quote.id = id;

			// Payment options
			if(this.insurer.payment_options.length){
				quote.payment_options = [];
				this.insurer.payment_options.forEach((payment_option) => {
					if(amount > payment_option.threshold){
						quote.payment_options.push({
							'description': payment_option.description,
							'id': payment_option.id,
							'name': payment_option.name
						});
					}
				});
			}

			// Policy type
			quote.policy_type = this.policy.type;
		});

		return quote;
	}

	/**
	 * Sends a request to an insurer over HTTPS
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} data - The data to be sent
	 * @param {object} additional_headers - Additional headers to be sent with the request, one header 'Content-Type' is required, all others are optional
	 * @param {string} method (optional) - The HTTP method to be used (e.g. POST or GET)
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */
	send_request(host, path, data, additional_headers, method){
		log.info(`${this.insurer.name} ${this.policy.type} Sending To ${path}`);
		const start_time = process.hrtime();

		return new Promise((fulfill, reject) => {

			// Determine which method to use
			if(!method){
				method = data ? 'POST' : 'GET';
			}

			// Check that we have a valid method
			if(!['GET',
				'POST',
				'PUT'].includes(method)){
				const error = new Error('Invalid method provided to send_request()');
				log.error(error.message);
				reject(error);
				return;
			}

			// Build the headers
			const headers = {};
			let content_type_found = false;
			if(additional_headers){
				for(const key in additional_headers){
					if(Object.prototype.hasOwnProperty.call(additional_headers, key)){
						if(key === 'Content-Type'){
							content_type_found = true;
							if(additional_headers[key] === 'application/x-www-form-urlencoded'){
								// Encode the data
								const querystring = require('querystring');
								data = querystring.stringify(data);
							}
							this.log += `--------======= Sending ${additional_headers[key]} =======--------<br><br>URL: ${host}${path}<br><br><pre>${htmlentities.encode(data)}</pre><br><br>`;
						}
						headers[key] = additional_headers[key];
					}
				}
			}
			if(!content_type_found){
				const error = new Error('No Content-Type header found. The Content-Type header is required for calls to send_request()');
				log.error(error.message);
				reject(error);
				return;
			}

			// Set the length parameter
			headers['Content-Length'] = data && data.length ? data.length : 0;

			// Set the request options
			const options = {
				'agent': false,
				'headers': headers,
				'hostname': host,
				'method': method,
				'path': path,
				'rejectUnauthorized': false,
				'requestCert': true,
				'timeout': 180000
			};

			const req = https.request(options, (res) => {
				let rawData = '';

				// Grab each chunk of data
				res.on('data', (d) => {
					rawData += d;
				});

				res.on('end', () => {
					// Calculate how long this took
					this.seconds = process.hrtime(start_time)[0];

					if(res.statusCode >= 200 && res.statusCode <= 299){

						// Strip AF Group's Quote Letter out of the log
						let filteredData = rawData.replace(/<com\.afg_Base64PDF>(.*)<\/com\.afg_Base64PDF>/, '<com.afg_Base64PDF>...</com.afg_Base64PDF>');

						// Strip Employer's Quote Letter out of the log
						filteredData = filteredData.replace(/<BinData>(.*)<\/BinData>/, '<BinData>...</BinData>');

						this.log += `--------======= Response =======--------<br><br><pre>${filteredData}</pre><br><br>`;
						fulfill(rawData);
					}else{
						const error = new Error(`Insurer request encountered a ${res.statusCode} error`);
						log.error(error.message);
						log.verbose(rawData);
						error.httpStatusCode = res.statusCode;
						error.response = rawData;
						this.log += `--------======= Error =======--------<br><br>Status Code: ${res.statusCode}<br><pre>${rawData}</pre><br><br>`;
						reject(error);
					}
				});
			});

			req.on('error', () => {
				this.log += `Connection to ${this.insurer.name} timedout.`;
				reject(new Error(`Connection to ${this.insurer.name} timedout.`));
			});

			if(data){
				req.write(data);
			}
			req.end();
		});
	}

	/**
	 * Sends an JSON request to this insurer
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} json - The JSON to be sent
	 * @param {object} additional_headers (optional) - Additional headers to be sent with the request
	 * @param {string} method (optional) - The HTTP method to be used
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */

	send_json_request(host, path, json, additional_headers, method){
		return new Promise(async(fulfill, reject) => {
			// If we don't have additional headers, start an object to append
			if(!additional_headers){
				additional_headers = {};
			}

			// Add in the JSON specific headers
			if(!Object.prototype.hasOwnProperty.call(additional_headers, 'Content-Type')){
				additional_headers['Content-Type'] = 'application/json';
			}
			additional_headers.accept = 'application/json';

			// Send the request
			await this.send_request(host, path, json, additional_headers, method).then((result) => {
				fulfill(JSON.parse(result));
			}).catch((error) => {
				reject(error);
			});
		});
	}


	/**
	 * Sends an XML request to this insurer
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} xml - The XML to be sent
	 * @param {object} additional_headers (optional) - Additional headers to be sent with the request
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */
	send_xml_request(host, path, xml, additional_headers){
		return new Promise(async(fulfill, reject) => {

			// If we don't have additional headers, start an object to append
			if(!additional_headers){
				additional_headers = {};
			}

			// Add in the content length header
			additional_headers['Content-Length'] = Buffer.byteLength(xml);

			// Add in the XML specific headers
			if(!Object.prototype.hasOwnProperty.call(additional_headers, 'Content-Type')){
				additional_headers['Content-Type'] = 'text/xml';
			}

			// Send the request
			await this.send_request(host, path, xml, additional_headers, 'POST').then((raw_data) => {

				// Convert the data to a string
				const str_data = raw_data.toString();

				// Convert the response to XML
				xmlToObj(str_data, (err, result) => {
					if(err){
						reject({// eslint-disable-line prefer-promise-reject-errors
							'message': 'Response from API was not XML',
							'raw': str_data
						});
						return;
					}

					fulfill(result);
				});
			}).catch((error) => {
				reject(error);
			});
		});
	}

	/**
	 * Determines whether or not this insurer supports all class codes in this application
	 *
	 * @returns {Promise.<object, Error>} A promise that returns an true or an object containing error information on success
	 */
	_insurer_supports_activity_codes(){
		return new Promise(async(fulfill) => {
			// Get all of the WC Codes with their ID and territory, removing duplicates
			const wcCodes = {};
			this.app.business.locations.forEach(function(location){
				location.activity_codes.forEach(function(activity_code){
					// Check if this code already existed
					if(!Object.prototype.hasOwnProperty.call(wcCodes, `${location.territory}${activity_code.id}`)){
						wcCodes[`${location.territory}${activity_code.id}`] = {
							'id': activity_code.id,
							'territory': location.territory
						};
					}
				});
			});

			// Build some WHERE statements from those codes
			const whereCombinations = Object.values(wcCodes).map(function(codeObj){
				return `(\`ac\`.\`id\` = ${db.escape(codeObj.id)} AND \`inc\`.\`territory\` = ${db.escape(codeObj.territory)})`;
			});

			// Query the database to get the corresponding codes
			let hadError = false;
			const sql = `
				SELECT
					\`ac\`.\`id\`,
					\`inc\`.\`state\`,
					\`inc\`.\`territory\`,
					\`inc\`.\`code\`,
					\`inc\`.\`sub\`,
					\`inc\`.\`result\`
				FROM \`#__activity_codes\` AS \`ac\`
				LEFT JOIN \`#__activity_code_associations\` AS \`aca\` ON \`ac\`.\`id\` = \`aca\`.\`code\`
				LEFT JOIN \`#__insurer_ncci_codes\` AS \`inc\` ON \`aca\`.\`insurer_code\` = \`inc\`.\`id\`
				WHERE \`inc\`.\`insurer\` = ${this.insurer.id} AND (${whereCombinations.join(' OR ')});
			`;
			const codes = await db.query(sql).catch((error) => {
				log.error(error);
				this.reasons.push('System Error: insurer_supports_activity_codes() failed to get codes.');
				fulfill(this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.'));
			});

			if(!codes.length){
				this.reasons.push('Out of Appetite: The insurer reports that they will not write a policy with the selected activity code');
				fulfill(this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time'));
				return;
			}

			// Make sure the number of codes matched (otherwise there were codes unsupported by this insurer)
			if(Object.keys(wcCodes).length !== codes.length){
				this.reasons.push('Out of Appetite: The insurer does not support one or more of the selected activity codes');
				fulfill(this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time'));
				return;
			}

			// Load the codes locally
			codes.forEach((code) => {
				if(code.result === 0){
					this.reasons.push('Out of Appetite: The insurer reports that they will not write a policy with the selected activity code');
					fulfill(this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time'));
					hadError = true;
					return;
				}
				if(code.state){
					this.insurer_wc_codes[code.territory + code.id] = code.code + (code.sub ? code.sub : '');
					return;
				}
				this.reasons.push('Out of Appetite: The insurer does not support one or more of the selected activity codes');
				fulfill(this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time'));
				hadError = true;
			});

			if(hadError){
				return;
			}

			fulfill(true);
		});
	}

	/**
	 * Determines whether or not this insurer supports all industry codes in this application
	 *
	 * @returns {Promise.<object, Error>} A promise that returns an true or an object containing error information on success
	 */
	_insurer_supports_industry_codes(){
		return new Promise(async(fulfill) => {
			// Query the database to see if this insurer supports this industry code
			const sql = `SELECT ic.id, ic.description, ic.cgl, ic.sic, ic.naics, ic.iso, iic.attributes FROM #__industry_codes AS ic LEFT JOIN #__insurer_industry_codes AS iic ON (iic.type = 'i' AND iic.code = ic.iso) OR (iic.type = 'c' AND iic.code = ic.cgl) OR (iic.type = 'n' AND iic.code = ic.naics) OR (iic.type = 's' AND iic.code = ic.sic) WHERE iic.insurer = ${this.insurer.id} AND ic.id = ${this.app.business.industry_code} AND iic.territory = '${this.app.business.primary_territory}' LIMIT 1;`;
			const result = await db.query(sql).catch(() => {
				fulfill(this.return_error('error', 'Well, that wasn\’t supposed to happen, but hang on, we\’ll get it figured out quickly and be in touch.'));
			});
			if(!result || !result.length){
				this.reasons.push('Out of Appetite: The insurer does not support the industry code selected');
				fulfill(this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time'));
				return;
			}

			this.industry_code = result[0];

			// If there are attributes, parse them for later use
			if(this.industry_code.attributes && Object.keys(this.industry_code.attributes).length > 0){
				this.industry_code.attributes = JSON.parse(this.industry_code.attributes);
			}else{
				this.industry_code.attributes = '';
			}

			fulfill(true);
		});
	}
};