/**
 * Defines a insurer integration
 */

'use strict';

const crypt = global.requireShared('./services/crypt.js');
const fileSvc = global.requireShared('./services/filesvc.js');
const htmlentities = require('html-entities').Html5Entities;
const https = require('https');
const moment = require('moment');
const util = require('util');
const {v4: uuidv4} = require('uuid');
const xmlToObj = util.promisify(require('xml2js').parseString);
const serverHelper = require('../../../../../server.js');
const xmlFormatter = require('xml-formatter');
// eslint-disable-next-line no-unused-vars
const tracker = global.requireShared('./helpers/tracker.js');
const jsonFunctions = global.requireShared('./helpers/jsonFunctions.js');
//const {getQuoteAggregatedStatus} = global.requireShared('./models/application-businesslogic/status.js');
const status = global.requireShared('./models/application-businesslogic/status.js');

const QuestionBO = global.requireShared('./models/Question-BO.js');
const QuoteBO = global.requireShared('./models/Quote-BO.js');


module.exports = class Integration {

    /**
     * Constructor for each integration
     *
     * @param {Application} app - An object containing all of the application information
     * @param {object} insurer - An object containing all of the insurer information
     * @param {object} policy - The data related to the current policy
     * @returns {void}
     */
    constructor(app, insurer, policy) {
        // Integration flags

        // requiresInsurerIndustryCodes:
        //      - set to true if the integration has insurer industry codes.
        //      - set to false if the integration does not have insurer industry codes.
        this.requiresInsurerIndustryCodes = false;

        // requiresInsurerActivityClassCodes:
        //      - set to true if the integration has insurer activity class codes.
        //      - set to false if the integration does not have insurer activity class codes.
        this.requiresInsurerActivityClassCodes = false;

        // requiresProductPolicyTypeFilter:
        //      - set to true if the policy type must be used to filter industry codes.
        //      - if set to true, set the policyTYpeFilter to the string policy type (f.e. 'GL')
        this.requiresProductPolicyTypeFilter = false;
        this.policyTypeFilter = null;

        // Integration Data
        this.app = app;
        this.industry_code = {};
        this.insurer = insurer;
        this.insurerDoc = null;   //mongo document for insurer.
        this.insurer_wc_codes = {};
        this.grouped_activity_codes = [];
        this.limits = {};
        this.log = '';
        //This is the quote number/id from
        this.number = '';
        this.policy = policy;
        this.questions = {};
        this.question_identifiers = {};
        this.question_details = {};
        this.request_id = '';
        this.seconds = 0;
        this.universal_questions = [];
        this.writer = '';
        this.quoteLink = '';

        // These are set in our insurer integration
        this.possible_api_responses = {};

        // These are generated by our insurer integration
        this.deductible = null;
        this.amount = 0;
        this.quote_letter = {};
        this.reasons = [];

        // Initialize the integration
        if (typeof this._insurer_init === "function") {
            try {
                this._insurer_init();
            }
            catch (err) {
                log.error('Integration insurer')
            }
        }

        // Apply WC payroll caps for Nevada
        if (this.policy.type === 'WC' && this.app.business && app.business.primary_territory === 'NV') {
            const nv_payroll_cap = 36000;

            // Loop through each location
            app.business.locations.forEach(function(location, location_index) {
                // Total the employees
                const total_employees = location.full_time_employees + location.part_time_employees;

                // Loop through each class code
                location.activity_codes.forEach(function(code, code_index) {
                    // If the payroll is over the cap, set it to the cap
                    if (code.payroll / total_employees > nv_payroll_cap) {
                        app.business.locations[location_index].activity_codes[code_index].payroll = nv_payroll_cap * total_employees;
                    }
                });
            });
        }
    }

    /**
     * An entry point for binding a quote that conducts some necessary pre-processing before calling the insurer_bind function.
     *
     * @returns {Promise.<string, ServerError>} A promise that returns a string containing bind result (either 'Bound' or 'Referred') if resolved, or a ServerError if rejected
     */
    bind() {
        log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Bind Started (mode: ${this.insurer.useSandbox ? 'sandbox' : 'production'})`);
        return new Promise(async(fulfill, reject) => {
            // Make sure the _bind() function exists
            if (typeof this._bind === 'undefined') {
                log.warn(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} integration does not support binding quotes` + __location);
                reject(serverHelper.notFoundError('Insurer integration does not support binding quotes at this time'));
                return;
            }

            // Check for an outage
            if (this.insurer.outage) {
                log.warn(`Appid: ${this.app.id} ${this.insurer.name} is currently unavailable due to scheduled maintenance` + __location);
                reject(serverHelper.serviceUnavailableError('Insurer is currently unavailable due to scheduled maintance'));
                return;
            }

            // Run the insurer's bind function
            await this._bind().
                then(function(result) {
                    fulfill(result);
                }).
                catch(function(error) {
                    reject(error);
                });
        });
    }

    /* Standardized log messages */

    /**
     * Returns a standard integration logging string in the format of:
     *  Appid: APPLICATION_ID INSURER_NAME (INSURER_ID) POLICY_TYPE: MESSAGE LOCATION
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {string} - the standard formatted string
     */
    log_message(message, location, extraData = null) {
        let logMessage = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type}: ${message}`;
        // Append extra data
        if (extraData) {
            Object.keys(extraData).forEach((key) => {
                logMessage += `, ${key}=${extraData[key]}`;
            });
        }
        // Append the location
        if (location) {
            logMessage += ' ' + location;
        }
        return logMessage;
    }

    /**
     * Logs the message and location to the debug log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_debug(message, location, extraData = null) {
        log.debug(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the verbose log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_verbose(message, location, extraData = null) {
        log.verbose(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the info log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_info(message, location, extraData = null) {
        log.info(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the warn log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_warn(message, location, extraData = null) {
        log.warn(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the error log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_error(message, location, extraData = null) {
        log.error(this.log_message(message, location, extraData));
    }

    /**
     * Retrieves an insurer-specific NCCI code for a given activity code
     *
     * @param {number} insurerId - The insurer ID
     * @param {string} territory - The 2 character territory code
     * @param {number} activityCode - The 4 digit Talage activity code
     * @returns {number} The 4 digit NCCI code
     */
    async get_insurer_code_for_activity_code(insurerId, territory, activityCode) {
        const policyEffectiveDate = moment(this.policy.effective_date).format(db.dbTimeFormat());

        const sql = `
            SELECT inc.code, inc.sub, inc.attributes
            FROM clw_talage_insurer_ncci_codes AS inc 
            LEFT JOIN clw_talage_activity_code_associations AS aca ON aca.insurer_code = inc.id
            WHERE
                inc.state = 1
                AND inc.insurer = ${insurerId}
                AND inc.territory = '${territory}'
                AND ('${policyEffectiveDate}' >= inc.effectiveDate AND '${policyEffectiveDate}' < inc.expirationDate)
                AND aca.code = ${activityCode};
        `;
        let result = null;
        try {
            result = await db.query(sql);
        }
        catch (error) {
            return null;
        }
        // Return if no results
        if (result.length === 0) {
            return null;
        }
        // Parse the attributes if they exist (non-fatal)
        if (result[0].attributes) {
            try {
                result[0].attributes = JSON.parse(result[0].attributes);
            }
            catch (error) {
                // continue. We may not need the attributes column
                log.error('JSON.parse(result[0].attributes) ' + error + __location);
                result[0].attributes = {};
            }
        }
        return result[0];
    }

    /**
     * Retrieves a national NCCI code from a given activity code
     *
     * @param {string} territory - The 2 character territory code
     * @param {number} activityCode - The 4 digit Talage activity code
     * @returns {object} The code and sub(code)
     */
    async get_national_ncci_code_from_activity_code(territory, activityCode) {
        // Retrieve a national NCCI code.
        // NOTE: we do not currently have these mapped but are in process; Adam is getting them.
        // Liberty codes mostly follow the national NCCI code numbering and we have most Liberty codes
        // mapped. So we use the Liberty code mapping for now until we have an official map of the
        // national NCCI codes. -SF
        const libertyRecord = await this.get_insurer_code_for_activity_code(14, territory, activityCode);
        if (!libertyRecord) {
            return null;
        }
        return libertyRecord.code;
    }

    /**
     * Returns an XML node child from parsed XML data. It will iterate down the node children, getting element 0 of each node's child.
     *
     * @param {object} node - top-level parent node
     * @param {Array} children - A dot-separated string of XML node names
     * @param {bool} returnRawLastNode - true if the returned child should be raw (NOT element zero of its node). Good if you want to iterate on the child node.
     * @returns {object} - Claims information lumped together by policy year
     */
    get_xml_child(node, children, returnRawLastNode = false) {
        const childrenList = children.split('.');
        let rawNode = node;
        for (const child of childrenList) {
            if (!node[child]) {
                return null;
            }
            rawNode = node[child];
            if (Array.isArray(rawNode)) {
                if (!rawNode.length) {
                    return null;
                }
                node = rawNode[0];
            }
            else {
                node = rawNode;
            }
        }
        return returnRawLastNode ? rawNode : node;
    }

    /**
     * Returns an object that includes Claims information based on policy years for up to the past 5 years
     *
     * @returns {object} - Claims information lumped together by policy year
     */
    claims_to_policy_years() {
        const claims = {};

        // Get the effective date of the policy
        const effective_date = this.policy.effective_date.clone();

        // Fill the claims object with some default data (for the policy year, year 1 is within effective date - 1 year, year 2 within 2 years, etc.)
        for (let i = 1; i <= 5; i++) {
            const c = {};
            c.amountPaid = 0;
            c.amountReserved = 0;
            c.count = 0;
            c.zeroPaidCount = 0;
            c.nonzeroPaidCount = 0;
            c.effective_date = effective_date.clone().subtract(i, 'years');
            c.expiration_date = c.effective_date.clone().add(1, 'years');
            c.missedWork = 0;
            claims[i] = c;
        }

        // Loop through each claim and add them to the claims object
        this.policy.claims.forEach((claim) => {
            // Determine the policy year
            let year = 0;
            for (let i = 1; i <= 5; i++) {
                if (claim.date.isAfter(this.policy.effective_date.clone().subtract(i, 'years'))) {
                    year = i;
                    break;
                }
            }

            // Make sure the claim was within the last 5 years
            if (!year) {
                return;
            }

            // Process this claim
            claims[year].amountReserved += claim.amountReserved;
            claims[year].amountPaid += claim.amountPaid;
            claims[year].count++;
            if (claim.missedWork) {
                claims[year].missedWork++;
            }
            if (claim.amountReserved || claim.amountPaid) {
                claims[year].nonzeroPaidCount++;
            }
            else {
                claims[year].zeroPaidCount++;
            }
        });

        return claims;
    }

    /**
     * Uses the activity codes from a single location combined with the insurer's specific NCCI codes to detect and combine any duplicates.
     *
     * @param {object} location - A single Location object
     * @returns {object} - The activity codes from within the location with any duplicates combined as code -> payroll pairs
     */
    combineLocationActivityCodes(location) {
        const returnCodes = {};
        location.activity_codes.forEach((activityCode) => {
            // Get the insurer's code for this activity
            const insurerCode = this.insurer_wc_codes[location.territory + activityCode.id];

            // Check if this code was already found
            if (Object.prototype.hasOwnProperty.call(returnCodes, insurerCode)) {
                // Combine the payroll
                returnCodes[insurerCode] += activityCode.payroll;
                return;
            }

            // This is a new one
            returnCodes[insurerCode] = activityCode.payroll;
        });

        return returnCodes;
    }

    /**
     * Determines the governing activity code for an application and returns the result.
     * The governing class code is determined by taking the activity code with the highest payroll. If there are two, the first code is used.
     * If the highest payroll code is our clerical code, it is ignored and the next highest is taken.
     *
     * @returns {object} - An ActivityCode object
     */
    determine_governing_activity_code() {
        // Group the activity codes
        this.group_activity_codes();

        // If there are not at least 2 activity codes, just return what we have
        if (this.grouped_activity_codes.length < 2) {
            return this.grouped_activity_codes[0];
        }

        // Sort the activity codes based on payroll
        this.grouped_activity_codes.sort(function compare(a, b) {
            if (a.payroll > b.payroll) {
                return -1;
            }
            if (a.payroll < b.payroll) {
                return 1;
            }
            return 0;
        });

        // Check if the highest payroll is our clerical code
        if (this.grouped_activity_codes[0].id === 2869) {
            // The highest payroll was clerical, reutrn the next highest instead
            return this.grouped_activity_codes[1];
        }
        // It wasn't clerical, return the highest payroll
        return this.grouped_activity_codes[0];
    }

    /**
     * Determines the proper answer to send to the insurer based on the question type. Return false if the question should be skipped.
     *
     * @param {object} question - A question object
     * @param {boolean} required - Whether or not this question is required by the insurer
     * @returns {mixed} - The answer to send to the insurer, or false if the question should be omitted
     */
    determine_question_answer(question, required) {
        let answer = false;

        // Default required
        required = required ? required : false;

        // Determine if the question is visible (its ancestors are all visible)
        let questionWasAnswered = true;
        let childQuestionId = question.id;
        while (this.questions.hasOwnProperty(childQuestionId) && this.questions[childQuestionId].parent !== 0) {
            // Get the parent ID. Ensure it is a string since the questions keys are strings.
            const parentQuestionId = this.questions[childQuestionId].parent;
            // Determine if the child question is visible
            if (!this.questions.hasOwnProperty(parentQuestionId) || this.questions[childQuestionId].parent_answer !== this.questions[parentQuestionId].answer_id) {
                questionWasAnswered = false;
                break;
            }
            childQuestionId = parentQuestionId;
        }
        // If not required and not answered, we return no answer
        if (!required && !questionWasAnswered) {
            return false;
        }

        // If this question has a parent that belongs to a different insurer it should have a default
        if (question.parent && !Object.prototype.hasOwnProperty.call(this.questions, question.parent) && question.answer_id === 0 && question.answer === null) {
            log.error(`Appid: ${this.app.id} Insurer: ${this.insurer.name} Question ${question.id} is missing a default answer. Defaulted to 'No' for this application. May cause quoting inaccuracies!` + __location);
            return 'No';
        }

        // If this is a checkbox, process each possible answer
        if (question.type === 'Checkboxes') {
            const answers = [];

            // Ensure the answers are an array
            if (Array.isArray(question.answer)) {
                // Loop over each possible answer
                for (let answer_id of question.answer) {
                    // Make sure the answer is permitted

                    // Ensure that the answer_id is a string, not a number.
                    // Note: on AWS servers, answer_id is a number; on other platforms, it is a string.
                    if (typeof answer_id !== "string") {
                        try {
                            answer_id = answer_id.toString();
                        }
                        catch (error) {
                            log.error(`Could not convert answer_id value ${answer_id} (type ${typeof answer_id}) to a string. Using original value.`);
                        }
                    }

                    if (!Object.prototype.hasOwnProperty.call(question.possible_answers, answer_id)) {
                        // This shouldn't have happened, throw an error
                        log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} encountered an answer to a question that is not possible. This should have been caught in the validation stage.` + __location);
                        log.verbose(`Appid: ${this.app.id} The question is as follows:`);
                        log.verbose(util.inspect(question, false, null));
                        throw new Error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} encountered an answer to a question that is not possible`);
                    }

                    // Add the answer to the answers array
                    answers.push(question.possible_answers[answer_id].answer);
                }
                // Return the answers as a comma separated string
                answer = answers.join(', ');
            }
            else {
                answer = '';
            }
            // If this is a Boolean or Select List question, get the answer expected by the carrier
        }
        else if (question.type === 'Yes/No' || question.type === 'Select List') {
            // Determine the answer based on the Answer ID stored in our database
            if (!Object.prototype.hasOwnProperty.call(question.possible_answers, question.answer_id)) {
                // This shouldn't have happened, throw an error
                log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} encountered an answer to a question that is not possible. This should have been caught in the validation stage.` + __location);
                log.verbose(`Appid: ${this.app.id} The question is as follows:`);
                log.verbose(util.inspect(question, false, null));
                throw new Error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} encountered an answer to a question that is not possible`);
            }

            answer = question.possible_answers[question.answer_id].answer;
        }
        else {
            // This is a fill-in-the-blank style question, simply send what the user gave us
            answer = question.answer;
        }

        return answer;
    }

    /**
     * Retrieves the relationship between questions and activity codes
     *
     * @returns {Promise.<object, Error>} A promise that returns an object indexed on territory + activity code (e.g. AZ908252) each with an array of corresponding question ideas if resolved, or an Error if rejected
     */
    get_activity_codes_to_questions_relationships() {
        return new Promise(async(fulfill, reject) => {
            // Only proceed if we have activity codes
            if (!this.insurer_wc_codes) {
                reject(new Error('No activity codes'));
                return;
            }

            // Loop over every location and build the WHERE clause of our query
            const where_chunks = [];
            this.app.business.locations.forEach((location) => {
                // And then every activity code in a location
                location.activity_codes.forEach((activity_code) => {
                    where_chunks.push(`(inc.\`code\` = '${this.insurer_wc_codes[location.territory + activity_code.id].substring(0, 4)}' AND inc.sub = '${this.insurer_wc_codes[location.territory + activity_code.id].substring(4, 6)}' AND inc.territory = '${location.territory}')`);
                });
            });

            // Build the SQL query
            const sql = `
				SELECT inc.territory, CONCAT(inc.\`code\`, inc.sub) AS class_code, GROUP_CONCAT(incq.question) AS questions
				FROM clw_talage_insurer_ncci_code_questions AS incq
				LEFT JOIN clw_talage_insurer_ncci_codes AS inc ON inc.id = incq.ncci_code AND inc.insurer = ${this.insurer.id}
				LEFT JOIN clw_talage_questions AS q ON incq.question = q.id
				WHERE q.state = 1 AND (${where_chunks.join(' OR ')}) GROUP BY inc.territory, class_code;
			`;
            const results = await db.query(sql).catch(function(error) {
                reject(error);
            });

            // Convert this into an object for easy reference
            const relationships = {};
            if (results) {
                results.forEach((result) => {
                    relationships[result.territory + result.class_code] = result.questions.split(',');
                });
            }

            // Return the result
            fulfill(relationships);
        });
    }

    /**
     * Determines the best limits available from the carrier. If no limits are suitable, returns false.
     *
     * @param {array} carrierLimits - A list of limits supported by the carrier
     * @returns {array|boolean} - An array containing limit values as integers, or false if none apply
     */
    getBestLimits(carrierLimits) {
        let higherLimit = null;

        // Take the requested limits and prepare them for processing
        const requestedLimits = this.getSplitLimits(this.policy.limits);

        // Prepare carrier limits for processing
        // eslint-disable-next-line prefer-const
        let splitCarrierLimitArray = carrierLimits.map(limit => this.getSplitLimits(limit));

        // Sort the limits by 1st, 2nd, then 3rd figure ascending to get the correct ordering
        splitCarrierLimitArray.sort((limit1, limit2) => limit1[0] - limit2[0]);
        splitCarrierLimitArray.sort((limit1, limit2) => limit1[1] - limit2[1]);
        splitCarrierLimitArray.sort((limit1, limit2) => limit1[2] - limit2[2]);

        // Some carriers support fewer than 3 limites. So we keep track of the "best" for 1, 2, or 3 limits
        // to allow fallback.
        let matchCount = 0;

        // Loop through all supported limits
        splitCarrierLimitArray.forEach((limitSet) => {
            if (limitSet[0] >= requestedLimits[0] && limitSet[1] >= requestedLimits[1] && limitSet[2] >= requestedLimits[2] && matchCount < 3) {
                higherLimit = limitSet;
                matchCount = 3;
            }
            else if (limitSet[0] >= requestedLimits[0] && limitSet[1] >= requestedLimits[1] & matchCount < 2) {
                higherLimit = limitSet;
                matchCount = 2;
            }
            else if (limitSet[0] >= requestedLimits[0] && matchCount < 1) {
                higherLimit = limitSet;
                matchCount = 1;
            }
        });

        return higherLimit;
    }

    /**
     * Returns the key (property) of an object based on the value of that property
     *
     * @param {object} obj - The object to search
     * @param {mixed} val - The value to find
     * @returns {string} - The key that matches
     */
    get_key_by_value(obj, val) {
        return Object.keys(obj).find((key) => obj[key] === val);
    }

    /**
     * Returns a description of the operations of the company based on the class codes they selected
     *
     * @returns {string} - The description of the business
     */
    get_operation_description() {
        return `${this.app.business.name} is a(n) ${this.app.business.industry_code_description.replace('&', 'and')} company with operations primarily located in ${this.app.business.locations[0].city}, ${this.app.business.locations[0].territory}.`;
    }

    /**
     * Gets the number of unique activity codes were included in this application
     *
     * @returns {int} - The number of activity codes
     */
    get_num_activity_codes() {
        // Group the activity codes
        this.group_activity_codes();

        // Return the count
        return this.grouped_activity_codes.length;
    }

    /**
     * Returns the number of claims that were within the number of years specified
     *
     * @param {int} number_of_years - The number of years of claims to total
     * @returns {int} - the number of claims
     */
    get_num_claims(number_of_years) {
        // Get the claims data organized by year
        const claims_by_year = this.claims_to_policy_years();

        // Loop through each year of claims
        let num_claims = 0;
        for (const claim_year in claims_by_year) {
            if (Object.prototype.hasOwnProperty.call(claims_by_year, claim_year)) {
                if (claim_year <= number_of_years) {
                    num_claims += claims_by_year[claim_year].count;
                }
            }
        }

        // Return the result
        return num_claims;
    }

    /**
     * Gets the details for each question for the current insurer. These details include the attributes, identifier, and whether or not the question is universal
     *
     * @returns {Promise.<object, Error>} A promise that returns an object containing objects indexed on the Talage Question ID with question information specific to this insurer if resolved, or an Error if rejected
     */
    async get_question_details() {
        const results = await this.getInsurerQuestionsByTalageQuestionId("general", Object.keys(this.questions));
        // Convert this into an object for easy reference
        const question_details = {};
        try {
            results.forEach((result) => {
                try{
                    let attributeJSON = '';
                    if (typeof result.attributes === 'object'){
                        attributeJSON = result.attributes;
                    }
                    else if (typeof result.attributes === 'string'){
                        attributeJSON = result.attributes ? JSON.parse(result.attributes) : ''
                    }
                    question_details[result.question] = {
                        insurerQuestionId: result.id,
                        attributes: attributeJSON,
                        identifier: result.identifier,
                        universal: result.universal
                    };
                    if (result.universal) {
                        this.universal_questions.push(result.question);
                    }
                }
                catch(err){
                    log.error(`Question details ${JSON.stringify(result)}: ` + err + __location);
                }
            });
        }
        catch (err) {
            log.error('Question details: ' + err + __location);
        }
        return question_details;
    }

    /**
     * Get insurer questions for given talage questions
     *
     * @param {string} questionSubjectArea - The question subject area ("general", "location", ...) Default is "general".
     * @param {Array} talageQuestionIdList - Array of Talage question IDs
     * @returns {Promise.<object, Error>} A promise that returns an object containing question information if resolved, or an Error if rejected
     */
    async getInsurerQuestionsByTalageQuestionId(questionSubjectArea, talageQuestionIdList) {
        if (talageQuestionIdList.length > 0) {
            if(global.settings.USE_MONGO_QUESTIONS === "YES"){
                const InsurerQuestionModel = require('mongoose').model('InsurerQuestion');
                const insurerQuestionQuery = {
                    talageQuestionId: {$in: talageQuestionIdList},
                    questionSubjectArea: questionSubjectArea,
                    active: true
                }
                // eslint-disable-next-line prefer-const
                let insurerQuestionList = await InsurerQuestionModel.find(insurerQuestionQuery)
                if(insurerQuestionList){
                    for(const insurerQuestion of insurerQuestionList){
                        //backwards compatible with mySql table column names
                        insurerQuestion.question = insurerQuestion.talageQuestionId
                    }
                    return insurerQuestionList;
                }
                else {
                    log.dbug("Integrations no insurers questions " + __location);
                    return [];
                }

            }
            else {
                const sql = `
                    SELECT id, question, universal, identifier, attributes FROM clw_talage_insurer_questions
                    WHERE
                        insurer = ${this.insurer.id} 
                        AND questionSubjectArea = '${questionSubjectArea}'
                        AND question IN (${talageQuestionIdList.join(',')});
                `;
                let results = null;
                try {
                    results = await db.query(sql);
                }
                catch (error) {
                    throw error;
                }
                return results;
            }
        }
        else {
            return [];
        }
    }

    /**
     * Retrieves the question that matches the identifier specified, returns false if none
     *
     * @param {string} identifier - The insurer identifier for the question
     * @returns {mixed} - question object on success, false otherwise
     */
    get_question_by_identifier(identifier) {
        // Loop through each question and check the identifier
        for (const question_id in this.questions) {
            if (Object.prototype.hasOwnProperty.call(this.questions, question_id)) {
                if (this.question_identifiers[question_id] === identifier) {
                    return this.questions[question_id];
                }
            }
        }
        return false;
    }

    /**
     * Gets the identifiers for each question for the current insurer
     *
     * @returns {Promise.<object, Error>} A promise that returns an object containing question information if resolved, or an Error if rejected
     */
    get_question_identifiers() {
        // log.info('get_question_identifiers FUNCTION IS DEPRECATED AND WILL BE REMOVED. USE get_question_details() INSTEAD WHICH RETURNS MORE DATA IN ONE QUERY');
        return new Promise(async(fulfill, reject) => {
            // Build an array of question IDs to retrieve
            const question_ids = Object.keys(this.questions);

            if (question_ids.length > 0) {
                if(global.settings.USE_MONGO_QUESTIONS === "YES"){
                    const InsurerQuestionModel = require('mongoose').model('InsurerQuestion');
                    const insurerQuestionQuery = {
                        talageQuestionId: {$in: question_ids},
                        insurerId: this.insurer.id,
                        active: true
                    }
                    const insurerQuestionList = await InsurerQuestionModel.find(insurerQuestionQuery)
                    if(insurerQuestionList){
                        const identifiers = {};
                        for(const insurerQuestion of insurerQuestionList){
                            identifiers[insurerQuestion.talageQuestionId] = insurerQuestion.identifier;
                            if (insurerQuestion.universal) {
                                this.universal_questions.push(insurerQuestion.talageQuestionId);
                            }
                        }
                        log.debug("Adding indentifiers " + JSON.stringify(identifiers))
                        fulfill(identifiers);
                    }
                    else {
                        fulfill({});
                    }

                }
                else {
                    const sql = `SELECT question, universal, identifier FROM clw_talage_insurer_questions WHERE insurer = ${this.insurer.id} AND question IN (${question_ids.join(',')});`;
                    const results = await db.query(sql).catch(function(error) {
                        reject(error);
                    });

                    // Convert this into an object for easy reference
                    const identifiers = {};
                    results.forEach((result) => {
                        identifiers[result.question] = result.identifier;
                        if (result.universal) {
                            this.universal_questions.push(result.question);
                        }
                    });

                    // Return the mapping
                    fulfill(identifiers);
                }
            }
            else {
                fulfill({});
            }
        });
    }

    /**
     * Splits a limits string into an array and coverts the values to integers
     *
     * @param {string} limits - A limits string
     * @returns {array} - An array of integers
     */
    getSplitLimits(limits) {
        return limits.split('/').map(function(val) {
            return parseInt(val, 10);
        });
    }

    /**
     * Returns the total incurred (paid + reserved) on claims that were within the number of years specified
     *
     * @param {int} number_of_years - The number of years of claims to total
     * @returns {int} - the number of claims
     */
    get_total_amount_incurred_on_claims(number_of_years) {
        // Get the claims data organized by year
        const claimsByYear = this.claims_to_policy_years();

        // Loop through each year of claims
        let total = 0;
        for (const year in claimsByYear) {
            if (Object.prototype.hasOwnProperty.call(claimsByYear, year)) {
                if (year <= number_of_years) {
                    total += claimsByYear[year].amountPaid;
                    total += claimsByYear[year].amountReserved;
                }
            }
        }

        // Return the result
        return total;
    }

    /**
     * Returns the total number of employees associated with this application
     *
     * @returns {int} - The total number of employees as an integer
     */
    get_total_employees() {
        let total = 0;
        this.app.business.locations.forEach(function(loc) {
            total += loc.full_time_employees;
            total += loc.part_time_employees;
        });
        return total;
    }

    /**
     * Returns the total number of full-time employees associated with this application
     *
     * @returns {int} - The total number of full-time employees as an integer
     */
    get_total_full_time_employees() {
        let total = 0;
        this.app.business.locations.forEach(loc => {
            total += loc.full_time_employees;
        });
        return total;
    }

    /**
     * Returns the total number of part-time employees associated with this application
     *
     * @returns {int} - The total number of part-time employees as an integer
     */
    get_total_part_time_employees() {
        let total = 0;
        this.app.business.locations.forEach(loc => {
            total += loc.part_time_employees;
        });
        return total;
    }

    /**
     * Returns the total payroll associated with this application
     *
     * @returns {int} - The total payroll as an integer
     */
    get_total_payroll() {
        let total = 0;
        this.app.business.locations.forEach(loc => {
            loc.activity_codes.forEach(wc_code => {
                total += wc_code.payroll;
            });
        });
        return total;
    }

    /**
     * Returns the total square footage of locations associated with this application
     *
     * @returns {int} - The total square footage as an integer
     */
    get_total_square_footage() {
        let total = 0;
        this.app.business.locations.forEach(function(loc) {
            total += loc.square_footage;
        });
        return total;
    }

    /**
     * Returns the number of years this business has operated
     *
     * @returns {int} - The total number of years in business
     */
    get_years_in_business() {
        // not correct for Employers Feb 2021.
        //return moment().diff(this.app.business.founded, 'years');
        if(this.app.applicationDocData.founded){
            return moment().diff(this.app.applicationDocData.founded, 'years');
        }
        else {
            return 0;
        }
    }

    /**
     * Returns the years since the last claim was filed. If claims were never filed, returns 999
     *
     * @returns {int} - The total number of years
     */
    get_years_since_claim() {
        if (!this.policy.claims.length) {
            return 999;
        }

        let years_ago = 999;
        this.policy.claims.forEach((claim) => {
            const num_years = moment().diff(claim.date, 'years');
            if (num_years < years_ago) {
                years_ago = num_years;
            }
        });
        return years_ago;
    }

    /**
     * Generates and returns a Version 4 UUID
     * Note: Version 4 UUIDs are completely random where Version 5 are not.
     *
     * @returns {string} - A random 36 character UUID formatted as follows 1f16f5d4-629b-11e7-b786-54616c616765
     */
    generate_uuid() {
        return uuidv4();
    }

    /**
     * Finds every activity code in an application and groups them together, adding their payrolls. Stores the result locally for later use.
     *
     * @returns {object} - An object with keys that are activity code ids, and values that are combined payrolls.
     */
    group_activity_codes() {
        // If this function has already run, simply return what we already determined
        if (this.grouped_activity_codes.length) {
            return this.grouped_activity_codes;
        }

        // First, localize all activity codes
        const activity_codes = [];

        // Get codes from all locations
        this.app.business.locations.forEach((location) => {
            // Loop through each code in this location
            location.activity_codes.forEach((activity_code) => {
                // Check if we have aleady seen this code on another location
                let seen = false;
                activity_codes.forEach((code, index) => {
                    if (activity_code.id === code.id) {
                        seen = true;

                        // Comine the payrolls for this code
                        activity_codes[index].payroll += activity_code.payroll;
                    }
                });

                if (!seen) {
                    // This is a new code, add it to our list
                    activity_codes.push(activity_code);
                }
            });
        });

        // Store the results locally for later use
        this.grouped_activity_codes = activity_codes;

        return activity_codes;
    }

    /**
     * An entry point for getting quotes that conducts some necessary pre-processing before calling the insurer_quote function.
     *
     * @returns {Promise.<object, Error>} A promise that returns an object containing quote information if resolved, or an Error if rejected
     */
    quote() {
        log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Quote Started (mode: ${this.insurer.useSandbox ? 'sandbox' : 'production'})`);
        return new Promise(async(fulfill) => {
            // Get the credentials ready for use
            this.password = await this.insurer.get_password();
            this.username = await this.insurer.get_username();

            // Make sure expiration_date is set
            if (this.policy && (!this.policy.expiration_date || !this.policy.expiration_date.isValid())) {
                log.warn(`Appid: ${this.app.id} Application ${this.app.id} policy had an invalid effective date. Setting it to 1 years after effective date. ${__location}`);
                this.policy.expiration_date = this.policy.effective_date.clone().add(1, 'years');
            }

            // Make sure the insurer_quote() function exists
            if (typeof this._insurer_quote === 'undefined') {
                const error_message = `Appid: ${this.app.id} Insurer: ${this.insurer.name} Integration file must include the insurer_quote() function`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                fulfill(this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.'));
                return;
            }

            // Check for outage - "outages" in Insurer class and database SQL
            if (this.insurer.outage) {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} is currently unavailable to planned outage`;
                this.reasons.push(error_message);
                fulfill(this.return_error('outage'));
                return;
            }

            // Check that industry codes codes are supported by the insurer if required
            if (!await this._insurer_supports_industry_codes() && this.requiresInsurerIndustryCodes) {
                // No industry codes when they are required
                fulfill(this.client_autodeclined_out_of_appetite());
                return;
            }

            // Check that activity class codes codes are supported by the insurer if required
            if (!await this._insurer_supports_activity_codes() && this.requiresInsurerActivityClassCodes) {
                // No activity class codes when they are required
                fulfill(this.client_autodeclined_out_of_appetite());
                return;
            }
            // if mongo pull insurer's Questions 
            let insurerQuestionList = null;
            if(global.settings.USE_MONGO_QUESTIONS === "YES"){
                const InsurerQuestionModel = require('mongoose').model('InsurerQuestion');
                const insurerQuestionQuery = {
                    insurerId: this.insurer.id,
                    policyType: this.policy.type,
                    active: true
                }
                insurerQuestionList = await InsurerQuestionModel.find(insurerQuestionQuery)

            }
            // Localize the questions and restrict them to only ones that are applicable to this insurer and policy type
            for (const question_id in this.app.questions) {
                if (Object.prototype.hasOwnProperty.call(this.app.questions, question_id)) {
                    try{
                        const question = this.app.questions[question_id];
                        if(global.settings.USE_MONGO_QUESTIONS === "YES"){
                            if(insurerQuestionList){
                                const iqHit = insurerQuestionList.find((iq) => iq.talageQuestionId === parseInt(question.id,10));
                                if(iqHit){
                                    this.questions[question_id] = question;
                                }
                            }
                            else {
                                log.debug(`No insurer question for ${this.insurer.id}-${this.policy.type}` + __location)
                            }
                        }
                        else if (question.insurers && question.insurers.includes(`${this.insurer.id}-${this.policy.type}`)){
                            this.questions[question_id] = question;
                        }
                    }
                    catch(err){
                        log.error(`error get question ${question_id} for ${this.insurer.id}-${this.policy.type} ` + __location)
                    }
                }
            }

            // Get the insurer question identifiers
            let stop = false;
            this.question_details = await this.get_question_details().catch((error) => {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get question details. ${error}`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                //Do not want to stop the rest of the quoting for application.
                // and end of quoting processing.
                //reject(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                stop = true;
            });
            this.question_identifiers = await this.get_question_identifiers().catch((error) => {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get question identifiers. ${error}`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                //Do not want to stop the rest of the quoting for application.
                // and end of quoting processing.
                //reject(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                stop = true;
            });
            if (stop) {
                return;
            }

            // ========================================================================================================================
            // Filter the application questions to remove hidden qustions, unanswered questions, and question for other carriers

            // Create a working copy of the applicationDocData just for this integration
            this.app.applicationDocData = jsonFunctions.jsonCopy(this.app.applicationDocData);

            // NOTE: filterApplicationQuestionListForInsurer will log its own errors

            // General questions
            const filteredGeneralQuestionList = await this.filterApplicationQuestionListForInsurer("general", this.app.applicationDocData.questions);
            if (!filteredGeneralQuestionList) {
                fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                return;
            }
            this.app.applicationDocData.questions = filteredGeneralQuestionList;

            // Location questions
            for (const location of this.app.applicationDocData.locations) {
                if (location.questions) {
                    const filteredLocationQuestionList = await this.filterApplicationQuestionListForInsurer("location", location.questions);
                    if (!filteredLocationQuestionList) {
                        fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                        return;
                    }
                    location.questions = filteredLocationQuestionList;
                    // Building questions?
                    // Vehicle questions?
                }
            }

            // Run the quote
            const appId = this.app.id;
            const insurerName = this.insurer.name;
            const policyType = this.policy.type
            await this._insurer_quote().
                then(function(result) {
                    fulfill(result);
                }).catch(function(error) {
                    const error_message = `Appid: ${appId} ${insurerName} ${policyType} is unable to quote ${error}`;
                    log.error(error_message + __location);
                    //Do not want to stop the rest of the quoting for application.
                    // and end of quoting processing.
                    //reject(error);
                    fulfill(null);
                });
        });
    }

    /**
     * Filter the question list to remove hidden questions, unanswered questions, and question for other carriers
     * This function logs its own errors.
     *
     * @param {string} questionSubjectArea - The question subject area ("general", "location", ...) Default is "general".
     * @param  {Array} applicationQuestionList - The question list
     * @returns {Array} filtered question list or null if error (errors are logged)
     */
    async filterApplicationQuestionListForInsurer(questionSubjectArea, applicationQuestionList) {
        // Create an array of Talage question IDs
        const talageQuestionIdList = applicationQuestionList.map((aq) => aq.questionId);

        // Get the insurer questions for those Talage question IDs
        let insurerQuestionList = null;
        try {
            // Get the insurer question identifiers for the question subject area
            insurerQuestionList = await this.getInsurerQuestionsByTalageQuestionId(questionSubjectArea, talageQuestionIdList);
        }
        catch (error) {
            const error_message = `Unable to get "${questionSubjectArea}" question identifiers.`;
            log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} ${error_message}: ${error}` + __location);
            this.reasons.push(error_message);
            return null;
        }

        // Retrieve the Talage questions for the application questions so we can determine both the parent hierarchy and the parent_answer for a child question
        const questionBO = new QuestionBO();
        const talageQuestionList = [];
        for (const applicationQuestion of applicationQuestionList) {
            let talageQuestion = null;
            try {
                talageQuestion = await questionBO.getById(applicationQuestion.questionId);
            }
            catch (error) {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get Talage question ${applicationQuestion.questionId}. ${error}}`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return null;
            }
            if (talageQuestion) {
                talageQuestionList.push(talageQuestion);
            }
            else {
                // Could not find the talage question by ID
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get Talage question ${applicationQuestion.questionId}: could not find ID.`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return null;
            }
        }

        const answeredApplicationQuestionList = [];

        // Remove non-answered questions.
        // This will walk all parents of a given application question up to the top-level question. If any of those parents
        // were answered in a way where it would not show the child (parent's answer != child's parent_answer), then the original
        // child was never asked and can be filtered out.
        for (const applicationQuestion of applicationQuestionList) {
            let questionWasAnswered = true;
            let childApplicationQuestion = applicationQuestion;
            let childTalageQuestion = talageQuestionList.find((tq) => tq.id === childApplicationQuestion.questionId);
            // While the question has a parent (not top-level)
            while (childTalageQuestion.parent) {
                // Find the parent application question for this child
                // eslint-disable-next-line no-loop-func
                const parentApplicationQuestion = applicationQuestionList.find((aq) => aq.questionId === childTalageQuestion.parent);
                if (!parentApplicationQuestion) {
                    questionWasAnswered = false;
                    break;
                }
                // Determine if the parent was answered such that the child became visible. If not, flag it and stop.
                if (childTalageQuestion.parent_answer && childTalageQuestion.parent_answer !== parentApplicationQuestion.answerId) {
                    questionWasAnswered = false;
                    break;
                }
                // Move up a question level (parent becomes child)
                // eslint-disable-next-line no-loop-func
                childTalageQuestion = talageQuestionList.find((tq) => tq.id === parentApplicationQuestion.questionId);
                childApplicationQuestion = parentApplicationQuestion;
            }
            // Add it to the filtered question list if the parent was answered
            if (questionWasAnswered) {
                answeredApplicationQuestionList.push(applicationQuestion);
            }
        }

        // Next we remove question for other insurers and hidden questions. This must be done AFTER we determine if a question was answered because
        // A parent question may be for another insurer (NOTE: that may lead to problems due to chicken/egg issue where an insurer's question
        // may be require but never asked because another the insurer's parent question was never answered -SF)
        const notHiddenInsurerApplicationQuestionList = [];
        for (const applicationQuestion of answeredApplicationQuestionList) {
            // Check if the application question is relevant to this insurer and isn't hidden. We do this by looking for the
            // Talage question ID in the insurer question list we retrieved above. If we find it, then this insurer asked it.
            const insurerQuestion = insurerQuestionList.find((iq) => iq.question === applicationQuestion.questionId);
            if (insurerQuestion && !applicationQuestion.hidden) {
                let insurerQuestionAttributes = null;
                if (insurerQuestion.attributes) {
                    try {
                        insurerQuestionAttributes = JSON.parse(insurerQuestion.attributes);
                    }
                    catch (error) {
                        log.warn(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Could not parse attributes for insurer question ${insurerQuestion.identifier}`);
                    }
                }
                applicationQuestion.insurerQuestionIdentifier = insurerQuestion.identifier;
                applicationQuestion.insurerQuestionAttributes = insurerQuestionAttributes;
                notHiddenInsurerApplicationQuestionList.push(applicationQuestion);
            }
        }

        return notHiddenInsurerApplicationQuestionList;
    }

    /**
     * Records this quote in the database so we know it happened
     *
     * @param {int} amount - The amount of the quote
     * @param {string} api_result - The integration's api result
     * @returns {mixed} - ID on success, error on error
     */
    async record_quote(amount, api_result) {
        const appId = this.app.id;
        const insurerName = this.insurer.name;
        const encrypted_log = await crypt.encrypt(this.log).catch(function(err) {
            log.error(`Unable to encrypt log. AppId ${appId} Insurer: ${insurerName}Proceeding anyway. ` + err + __location);
        });

        const columns = [
            'application',
            'insurer',
            'log',
            'policy_type',
            'seconds',
            'created'
        ];
        const values = [
            this.app.id,
            this.insurer.id,
            encrypted_log ? encrypted_log : '',
            this.policy.type,
            this.seconds,
            moment().format('YYYY-MM-DD HH:mm:ss')
        ];
        //build mongo Document
        const quoteJSON = {
            mysqlAppId: this.app.id,
            insurerId: this.insurer.id,
            log: this.log,
            policyType: this.policy.type,
            quoteTimeSeconds: this.seconds
        }
        //additionalInfo example

        // Amount
        if (amount) {
            columns.push('amount');
            values.push(amount);
            quoteJSON.amount = amount;
        }

        // Deductible
        if (this.deductible !== null) {
            // do not put in mysql
            // columns.push('deductible');
            // values.push(this.deductible);
            quoteJSON.deductible = this.deductible;
        }

        // Number
        if (this.number) {
            quoteJSON.quoteNumber = this.number
            columns.push('number');
            values.push(this.number);
        }

        // Request ID
        if (this.request_id) {
            columns.push('request_id');
            values.push(this.request_id);
            quoteJSON.requestId = this.request_id
        }

        // Writer
        if (this.writer) {
            columns.push('writer');
            values.push(this.writer);
            quoteJSON.writer = this.writer
        }
        if(this.quoteLink){
            columns.push('quote_link');
            values.push(this.quoteLink);
            quoteJSON.quoteLink = this.quoteLink
        }

        // Error
        columns.push('api_result');
        values.push(api_result);
        quoteJSON.apiResult = api_result

        // Reasons
        if (this.reasons.length > 0) {
            columns.push('reasons');
            values.push(this.reasons.join(',').replace(/'/g, "\\'").substring(0, 500));
            // Note: we do not need to escape apostrophes when going to Mongo. This was causing quote reasons to show an escape apostrophe in the agency portal -SF
            quoteJSON.reasons = this.reasons.join(',');
        }

        // Quote Letter
        if (this.quote_letter && Object.prototype.hasOwnProperty.call(this.quote_letter, 'data') && this.quote_letter.data) {
            // Generate a UUID to use as the file name
            const fileName = `${this.generate_uuid()}.pdf`;

            // Store the quote letter in our cloud storage
            try {
                // Store the quote letter in our cloud storage
                // Secure
                const result = await fileSvc.PutFileSecure(`secure/quote-letters/${fileName}`, this.quote_letter.data);
                // The file was successfully saved, store the file name in the database
                if (result && result.code === 'Success') {
                    columns.push('quote_letter');
                    values.push(fileName);
                    quoteJSON.quoteLetter = fileName
                }
            }
            catch (err) {
                log.error(`Appid: ${this.app.id} Insurer: ${this.insurer.name} S3 error Storing Quote letter : ${fileName} error: ` + err + __location);
            }
        }

        // Aggregated Status.
        columns.push('aggregated_status');
        const aggregatedStatus = status.getQuoteAggregatedStatus(false, '', api_result);
        values.push(aggregatedStatus);
        quoteJSON.aggregatedStatus = aggregatedStatus

        if (Object.keys(this.limits).length) {
            quoteJSON.limits = []
            // eslint-disable-next-line guard-for-in
            for (const limitId in this.limits) {
                if (Object.prototype.hasOwnProperty.call(this.limits, limitId)) {
                    const limitJSON = {
                        limitId: limitId,
                        amount: this.limits[limitId]
                    }
                    quoteJSON.limits.push(limitJSON);
                }
            }
        }
        //QuoteBO
        const quoteBO = new QuoteBO();
        const quoteID = await quoteBO.saveIntegrationQuote(quoteJSON, columns, values).catch(function(err){
            log.error("Error quoteBO.insertByColumnValue " + err + __location);
        });

        return quoteID;
    }

    /**
     * Returns a quote object for an auto-declined quote
     *
     * @param {string} publicMessage - Message to display to the customer
     * @param {Array} extraReasonList - Array of strings listing additional decline reasons
     * @returns {object} - An object containing the quote information
     */
    async client_declined(publicMessage = null, extraReasonList = null) {
        if (!publicMessage) {
            publicMessage = "The insurer has declined to offer you coverage at this time.";
        }
        this.reasons.push(publicMessage);
        if (extraReasonList) {
            for (const extraReason of extraReasonList) {
                this.reasons.push(extraReason);
            }
        }
        this.log_info(`Declined with message '${publicMessage}'`, __location, {extraReasonList: extraReasonList});
        return this.return_result('declined');
    }

    /**
     * Returns a quote object for an auto-declined quote
     *
     * @param {string} publicMessage - Message to display to the customer
     * @param {object} extraLogData - Data to append to the logging message
     * @returns {object} - An object containing the quote information
     */
    async client_autodeclined(publicMessage, extraLogData = null) {
        this.reasons.push(publicMessage);
        this.log_info(`Autodeclined with message '${publicMessage}'`, __location, extraLogData);
        return this.return_result('autodeclined');
    }

    /**
     * Returns a quote object for an auto-declined out of appetite quote
     *
     * @returns {object} - An object containing the quote information
     */
    async client_autodeclined_out_of_appetite() {
        return this.client_autodeclined('Out of Appetite: The insurer reports that they will not write a policy with the selected state and industry or activity code');
    }

    /**
     * Returns a quote object for a 'referred' quote
     *
     * @param {string} quoteNumber - The quote's number for the given insurer (optional, but encouraged)
     * @param {int} limits - The limits parsed from the quote
     * @param {int} premiumAmount - The premium amount (optional)
     * @param {string} quoteLetter - The quote letter (optional)
     * @param {int} quoteLetterMimeType - Quote letter mime type (optional, default = "application/base64")
     * @returns {object} - An object containing the quote information
     */
    async client_referred(quoteNumber, limits, premiumAmount = null, quoteLetter = null, quoteLetterMimeType = null) {
        if (!limits || Object.keys(limits).length === 0) {
            this.log_error('Received a referred quote but no limits', __location);
            return this.return_error('error', `Could not locate the limits in the quote returned from the carrier.`);
        }
        this.limits = limits;
        if (premiumAmount) {
            this.amount = premiumAmount;
        }
        if (quoteNumber) {
            this.number = quoteNumber;
        }
        if (quoteLetter) {
            this.quote_letter = {
                content_type: quoteLetterMimeType ? quoteLetterMimeType : "application/base64",
                data: quoteLetter,
                file_name: `${this.insurer.name}_ ${this.policy.type}_quote_letter.pdf`
            };
        }

        const message = `Referred${premiumAmount ? ` with premium $${premiumAmount}` : ""}`;
        this.log += `<br>${message}<br><br>\n`;
        this.log_info(message, __location);

        return this.return_result('referred');
    }

    /**
     * Returns a quote object for a 'quoted' quote
     *
     * @param {string} quoteNumber - The quote's number for the given insurer (optional, but encouraged)
     * @param {array} limits - The limits parsed from the quote
     * @param {int} premiumAmount - The premium amount
     * @param {string} quoteLetter - The quote letter (optional)
     * @param {int} quoteLetterMimeType - Quote letter mime type (optional, default = "application/base64")
     * @returns {object} - An object containing the quote information
     */
    async client_quoted(quoteNumber, limits, premiumAmount, quoteLetter = null, quoteLetterMimeType = null) {
        if (!limits) {
            this.log_error(`Received a quote but no limits for Appid: ${this.app.id} Insurer: ${this.insurer.name}`, __location);
            return this.return_error('error', `Could not locate the limits in the quote returned from the carrier.`);
        }
        this.limits = limits;

        if (!premiumAmount) {
            this.log_error(`Received a quote but no premium amount for Appid: ${this.app.id} Insurer: ${this.insurer.name}`, __location);
            return this.return_error('error', `Could not locate the limits in the quote returned from the carrier.`);
        }
        this.amount = premiumAmount;

        if (quoteNumber) {
            this.number = quoteNumber;
        }

        if (quoteLetter) {
            this.quote_letter = {
                content_type: quoteLetterMimeType ? quoteLetterMimeType : "application/base64",
                data: quoteLetter,
                file_name: `${this.insurer.name}_${this.policy.type}_quote_letter.pdf`
            };
        }

        const message = `Quoted with premium $${premiumAmount}`;
        this.log += `<br>${message}<br><br>\n`;
        this.log_info(message, __location);

        // Record the quote
        const quoteResp = await this.record_quote(premiumAmount, 'quoted');
        return quoteResp;
    }

    /**
     * Returns a quote object for an 'error' condition
     *
     * @param {string} publicMessage - Message to display to the customer
     * @param {string} location - location of the error (set to __location)
     * @param {object} extraLogData - Data to append to the logging message
     * @returns {object} - An object containing the quote information
     */
    async client_error(publicMessage, location, extraLogData = null) {

        // Log the public message
        this.log += `<b>Error:</b> ${publicMessage}<br><br>`;
        this.reasons.push(publicMessage);
        this.log_error(publicMessage, location, extraLogData);

        // Return the error with the customer-facing message
        return this.return_error('error', publicMessage);
    }

    /**
     * Returns a quote object for an auto-declined quote
     *
     * @param {string} location - location of the error (set to __location)
     * @param {object} extraLogData - Data to append to the logging message
     * @returns {object} - An object containing the quote information
     */
    async client_connection_error(location, extraLogData = null) {
        return this.client_error('Could not connect to the insurer\'s servers at this time.', location, extraLogData);
    }

    /**
	 * Generates and returns the proper structure for returning a quote from an integration
	 *
	 * @param {int} amount - The amount of the quote as a whole number
	 * @returns {object} - An object containing the quote information
	 */
    async return_quote(amount) {
        const result = await this.record_quote(amount, 'quoted');
        return result;
    }

    /**
	 * Generates and returns the proper structure for returning an indication from an integration
	 *
	 * @param {int} amount - The amount of the indication as a whole number
	 * @returns {object} - An object containing the indication information
	 */
    async return_indication(amount) {
        const quoteResp = await this.record_quote(amount, 'referred_with_price');
        return quoteResp;
    }

    /**
	 * Generates and returns the proper structure for returning an error from an integration
	 *
	 * @param {string} type - The type of error
	 * @param {string} message - A user friendly description of the error
	 * @returns {object} - An error object
	 */
    async return_error(type, message) {
        log.info(`Appid: ${this.app.id} ${this.insurer.name} returned an error of type ${type} for a ${this.policy.type} policy: ${message}` + __location);

        // If there were reasons, make sure we write them to the log
        if (this.reasons.length > 0) {
            this.reasons.forEach((reason) => {
                log.verbose(reason);
            });
        }

        // Record this quote
        const quoteResp = await this.record_quote(null, type);
        return quoteResp;
    }

    /**
	 * Returns an object of the limits for this policy with the propery as the limit description and the value as the amount
	 *
	 * @returns {object} - The limit information
	 */
    async returnLimits() {
        const rtn = {};

        // If there is no limits data, just return an empty object
        if (!Object.keys(this.limits).length) {
            return rtn;
        }

        // Get the limit descriptions from the database
        // TODO USE BO
        const result = await db.query(`SELECT * FROM \`#__limits\` WHERE \`id\` IN (${Object.keys(this.limits).join(',')}) ORDER BY description ASC;`).catch(function(err) {
            return err;
        });

        // Loop through the results and build the response
        result.forEach((limitInfo) => {
            rtn[limitInfo.description] = this.limits[limitInfo.id];
        });

        return rtn;
    }

    /**
	 * Determines which response should be sent, and sends it. This should be called by every insurer integration.
	 *
	 * @param {string} result - The result of the integration. Must be 'declined', 'quoted', 'referred', or 'referred_with_price'
	 * @returns {mixed} - An object containing the response to be sent to the user on success, false on failure
	 */
    return_result(result) {
        // Determine the log messages to show
        const log_messages = {
            autodeclined: 'System Autodeclined',
            declined: 'Application Declined',
            error: 'Integration Error',
            outage: 'Insurer System Outage',
            quoted: 'Quote Recieved',
            referred: 'Application Referred',
            referred_with_price: 'Application Referred With Price',
            acord_emailed: 'Acord Form Emailed'
        };

        // Make sure we have a result
        if (!result) {
            const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Missing argument for return_result(). Must pass in a valid value for result.`;
            log.error(error_message + __location);
            this.reasons.push(error_message);
            return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');
        }

        // Make sure the result is one of the ones we are expecting
        if (!Object.keys(log_messages).includes(result)) {
            // If result is a possible API result from an integration, convert it to the Talage equivalent
            if (Object.keys(this.possible_api_responses).includes(result)) {
                result = this.possible_api_responses[result];
            }
            else {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Invalid value of '${result}' for result passed to return_result(). Result not specified in the insurer integration.`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');
            }

            // Double check: Is the result now what we are expecting
            if (!Object.keys(log_messages).includes(result)) {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Invalid value of '${result}' for result passed to return_result(). Must be a valid value as defined in return_result().`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');
            }
        }

        // Check if this was referred, but a price was still provided, and if so, update the status
        if ((result === 'referred' || this.indication) && this.amount) {
            result = 'referred_with_price';
        }

        // If this was quoted, make sure we have an amount
        if ((result === 'quoted' || result === 'referred_with_price') && !this.amount) {
            log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Unable to find quote amount. Response structure may have changed.` + __location);
            this.reasons.push(`${this.insurer.name} ${this.policy.type} Integration Error: Unable to find quote amount. Response structure may have changed.`);
            if (result === 'quoted') {
                result = 'error';
            }
            else {
                result = 'referred';
            }
        }

        // If this was quoted, make sure we have limits
        if ((result === 'quoted' || result === 'referred_with_price') && !Object.keys(this.limits).length) {
            log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Unable to find limits. Response structure may have changed.` + __location);
        }

        // Start the log message
        this.log += `--------======= ${log_messages[result]} =======--------<br><br>`;

        // Log the amount
        if (this.amount) {
            this.log += `Quote: ${this.amount}<br>`;
        }

        // Log the reasons
        if (this.reasons.length > 0) {
            this.log += `The insurer returned the following reasons for why they made this decision:<ul><li>${this.reasons.join('</li><li>')}</li></ul>`;
        }

        // Take the appropriate action
        switch (result) {
            case 'autodeclined':
                return this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time');

            case 'declined':
                if (this.reasons) {
                    this.reasons.forEach(function(reason) {
                        log.verbose(reason);
                    });
                }
                this.reasons.push('Declined by insurer');
                return this.return_error('declined', `${this.insurer.name} has declined to offer you coverage at this time`);

            case 'error':
                log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Encountered An Error` + __location);
                if (this.reasons) {
                    //this.reasons.forEach(function(reason) {
                    for(let i = 0; i < this.reasons.length; i++){
                        log.error(`Appid: ${this.app.id} Insurer: ${this.insurer.name} ` + this.reasons[i] + __location);
                    }
                }
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');

            case 'outage':
                log.warn(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Experienced A System Outage At The Time of Quote` + __location);
                if (this.reasons) {
                    this.reasons.forEach(function(reason) {
                        log.verbose(reason);
                    });
                }
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');

            case 'quoted':
                log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Returned Quote(s)` + __location);
                return this.return_quote(this.amount);

            case 'referred':
                if (this.reasons) {
                    this.reasons.forEach(function(reason) {
                        log.verbose(reason);
                    });
                }
                return this.return_error('referred', `Appid: ${this.app.id} ${this.insurer.name} needs a little more time to make a decision`);
            case 'acord_emailed':
                return this.return_error('acord_emailed', `Appid: ${this.app.id} ${this.insurer.name} AgencyLocation ${this.app.agencyLocation.id} acord form sent`);
            case 'referred_with_price':
                log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Referred To Underwriting, But Provided An Indication` + __location);
                return this.return_indication(this.amount);

            default:
        }
    }

    /**
	 * Gets a formatted XML string
     *
     * @param {string} str - A string which may or may not be valid XML
     * @returns {string | null} A formatted XML string for valid JSON input, null otherwise
	 */
    get_formatted_xml_string(str) {
        // Format XML to be readable
        let formattedString = '';
        try {
            formattedString = xmlFormatter(str);
        }
        catch (error) {
            return null;
        }
        return formattedString;
    }

    /**
	 * Gets a formatted JSON string
     *
     * @param {string} str - A string which may or may not be valid JSON
     * @returns {string | null} A formatted JSON string for valid JSON input, null otherwise
	 */
    get_formatted_json_string(str) {
        let formattedString = '';
        try {
            formattedString = JSON.stringify(JSON.parse(str), null, 4);
        }
        catch (error) {
            return null;
        }
        return formattedString;
    }

    /**
	 * Sends a request to an insurer over HTTPS
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} data - The data to be sent
	 * @param {object} additional_headers - Additional headers to be sent with the request, one header 'Content-Type' is required, all others are optional
	 * @param {string} method (optional) - The HTTP method to be used (e.g. POST or GET)
     * @param {boolean} log_errors - True if error logging should be handled here, false if error logging is handled in the client
     * @param {boolean} returnResponseOnAllStatusCodes - True if response should be returned (fulfilled) on all HTTP status codes, false if it should reject (default)
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */
    send_request(host, path, data, additional_headers, method, log_errors = true, returnResponseOnAllStatusCodes = false) {
        log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Sending To ${path}` + __location);
        const start_time = process.hrtime();

        return new Promise((fulfill, reject) => {
            // Determine which method to use
            if (!method) {
                method = data ? 'POST' : 'GET';
            }

            // Check that we have a valid method
            if (![
                'GET',
                'POST',
                'PUT'
            ].includes(method)) {
                const error = new Error(`Appid: ${this.app.id} calling ${this.insurer.name} Invalid method provided to send_request()`);
                log.error(error.message + __location);
                reject(error);
                return;
            }

            // Add a timestamp to the request log
            this.log += `<b>Request started at ${moment().utc().toISOString()}</b><br><br>`;

            // Build the headers
            const headers = {};
            let content_type_found = false;
            if (additional_headers) {
                for (const key in additional_headers) {
                    if (Object.prototype.hasOwnProperty.call(additional_headers, key)) {
                        if (key === 'Content-Type') {
                            content_type_found = true;
                            if (additional_headers[key] === 'application/x-www-form-urlencoded') {
                                // Encode the data
                                const querystring = require('querystring');
                                data = querystring.stringify(data);
                            }
                            let formattedString = data;
                            // Attempt to format it if it is a XML string
                            const formattedXMLString = this.get_formatted_xml_string(data);
                            if (formattedXMLString) {
                                formattedString = formattedXMLString;
                            }
                            else {
                                // Attempt to format it if it is a JSON string
                                const formattedJSONString = this.get_formatted_json_string(data);
                                if (formattedJSONString) {
                                    formattedString = formattedJSONString;
                                }
                            }
                            // Log the request
                            this.log += `--------======= Sending ${additional_headers[key]} =======--------<br><br>`;
                            this.log += `URL: ${host}${path}<br><br>`;
                            this.log += `<pre>${htmlentities.encode(formattedString)}</pre><br><br>`;
                        }
                        headers[key] = additional_headers[key];
                    }
                }
            }
            if (!content_type_found) {
                const error = new Error(`Appid: ${this.app.id} calling ${this.insurer.name} No Content-Type header found. The Content-Type header is required for calls to send_request()`);
                log.error(error.message + __location);
                reject(error);
                return;
            }

            // Set the length parameter
            headers['Content-Length'] = data && data.length ? Buffer.byteLength(data) : 0;

            // Set the request options
            const options = {
                agent: false,
                headers: headers,
                hostname: host,
                method: method,
                path: path,
                rejectUnauthorized: false,
                requestCert: true,
                timeout: 180000
            };

            const req = https.request(options, (res) => {
                let rawData = '';
                log.debug("in https response " + __location)
                // Grab each chunk of data
                res.on('data', (d) => {
                    rawData += d;
                });

                res.on('end', () => {
                    // Calculate how long this took
                    this.seconds = process.hrtime(start_time)[0];

                    // Attempt to format the returned data
                    let formattedData = rawData;
                    if (headers['Content-Type'] && headers['Content-Type'].toLowerCase() === 'text/xml') {
                        // Format XML to be readable
                        const formattedXMLData = this.get_formatted_xml_string(rawData);
                        if (formattedXMLData) {
                            formattedData = formattedXMLData;
                        }
                    }
                    else if (headers['Content-Type'] && headers['Content-Type'].toLowerCase() === 'application/json') {
                        // Format JSON to be readable
                        const formattedJSONData = this.get_formatted_json_string(rawData);
                        if (formattedJSONData) {
                            formattedData = formattedJSONData;
                        }
                    }
                    if (res.statusCode >= 200 && res.statusCode <= 299 || returnResponseOnAllStatusCodes) {
                        // Strip AF Group's Quote Letter out of the log
                        formattedData = formattedData.replace(/<com\.afg_Base64PDF>(.*)<\/com\.afg_Base64PDF>/, '<com.afg_Base64PDF>...</com.afg_Base64PDF>');

                        // Strip Employer's Quote Letter out of the log
                        formattedData = formattedData.replace(/<BinData>(.*)<\/BinData>/, '<BinData>...</BinData>');

                        // Strip Acuity's Quote Letter out of the log
                        formattedData = formattedData.replace(/<!\[CDATA.*>/, '<![CDATA[...]]>');

                        this.log += `--------======= Response Appid: ${this.app.id}  =======--------<br><br>`;
                        this.log += `<pre>${htmlentities.encode(formattedData)}</pre><br><br>`;
                        fulfill(rawData);
                    }
                    else{
                        const error = new Error(`Appid: ${this.app.id} insurer request encountered a ${res.statusCode} error`);
                        // Added check - do not log errors if there is a special response case for the client to handle
                        if(log_errors){
                            log.error(error.message + `  Appid: ${this.app.id} calling ${this.insurer.name} ` + __location);
                            log.verbose(rawData);
                            this.log += `--------======= Error Appid: ${this.app.id} calling ${this.insurer.name}  =======--------<br><br>`;
                            this.log += `Status Code: ${res.statusCode} <br>`;
                            this.log += `<pre>${htmlentities.encode(formattedData)}</pre><br><br>`;
                        }
                        error.httpStatusCode = res.statusCode;
                        error.response = rawData;
                        reject(error);
                    }
                });
                
            });

            req.on('error', (err) => {
                log.error(`Connection to ${this.insurer.name} timedout. error ${err}` + __location);
                this.log += `Connection to ${this.insurer.name} timedout. error ${err} `;
                reject(new Error(`Appid: ${this.app.id} Connection to ${this.insurer.name} terminated. Reason: ${err.code}`));
            });

            if (data) {
                req.write(data);
            }
            req.end();
        });
    }

    /**
	 * Sends an JSON request to this insurer
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} json - The JSON to be sent
	 * @param {object} additional_headers (optional) - Additional headers to be sent with the request
	 * @param {string} method (optional) - The HTTP method to be used
     * @param {boolean} log_errors - True if errors should be logged, false otherwise
     * @param {boolean} returnResponseOnAllStatusCodes - True if response should be returned (fulfilled) on all HTTP status codes, false if it should reject (default)
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */

    send_json_request(host, path, json, additional_headers, method, log_errors = true, returnResponseOnAllStatusCodes = false) {
        return new Promise(async(fulfill, reject) => {
            // If we don't have additional headers, start an object to append
            if (!additional_headers) {
                additional_headers = {};
            }

            // Add in the JSON specific headers
            if (!Object.prototype.hasOwnProperty.call(additional_headers, 'Content-Type')) {
                additional_headers['Content-Type'] = 'application/json';
            }
            additional_headers.accept = 'application/json';

            // Send the request
            await this.send_request(host, path, json, additional_headers, method, log_errors, returnResponseOnAllStatusCodes).
                then((result) => {
                    fulfill(JSON.parse(result));
                }).
                catch((error) => {
                    reject(error);
                });
        });
    }

    /**
	 * Sends an XML request to this insurer
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} xml - The XML to be sent
	 * @param {object} additional_headers (optional) - Additional headers to be sent with the request
	 * @param {boolean} dumpRawXML (optional) - Dump the raw XML response to the console
     * @param {boolean} returnResponseOnAllStatusCodes - True if response should be returned (fulfilled) on all HTTP status codes, false if it should reject (default)
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */
    async send_xml_request(host, path, xml, additional_headers, dumpRawXML = false, returnResponseOnAllStatusCodes = false) {
        // return new Promise(async(fulfill, reject) => {
        // If we don't have additional headers, start an object to append
        if (!additional_headers) {
            additional_headers = {};
        }

        // Add in the content length header
        additional_headers['Content-Length'] = Buffer.byteLength(xml);

        // Add in the XML specific headers
        if (!Object.prototype.hasOwnProperty.call(additional_headers, 'Content-Type')) {
            additional_headers['Content-Type'] = 'text/xml';
        }

        // Send the request
        let raw_data = null;
        try {
            raw_data = await this.send_request(host, path, xml, additional_headers, 'POST', true, returnResponseOnAllStatusCodes);
        }
        catch (error) {
            log.error(`Appid: ${this.app.id} calling ${this.insurer.name} Integration send_request error: ${error}` + __location);
            // reject(error);
            throw error;
        }
        // Convert the data to a string
        const str_data = raw_data.toString();

        if (dumpRawXML) {
            // eslint-disable-next-line no-console
            console.log(xmlFormatter(str_data, {collapseContent: true}));
        }

        // Convert the response to XML
        let result = null;
        try {
            result = xmlToObj(str_data);
        }
        catch (error) {
            const errData = {
                // eslint-disable-line prefer-promise-reject-errors
                message: 'Response from API was not XML',
                raw: str_data
            };
            throw new Error(JSON.stringify(errData));
        }
        return result;
    }

    /**
	 * Determines whether or not this insurer supports all class codes in this application
	 *
	 * @returns {Promise.<boolean>} A promise that returns an true if the insurer supports the activity code and populates them, false otherwise
	 */
    _insurer_supports_activity_codes() {
        return new Promise(async(fulfill) => {
            // Get all of the WC Codes with their ID and territory, removing duplicates
            const wcCodes = {};
            let hasActivityCodes = false;
            this.app.business.locations.forEach(function(location) {
                location.activity_codes.forEach(function(activity_code) {
                    // Check if this code already existed
                    if (!Object.prototype.hasOwnProperty.call(wcCodes, `${location.territory}${activity_code.id}`)) {
                        wcCodes[`${location.state}${activity_code.id}`] = {
                            id: activity_code.id,
                            territory: location.territory
                        };
                        hasActivityCodes = true;
                    }
                });
            });
            if(hasActivityCodes === false) {
                if(this.requiresInsurerActivityClassCodes){
                    log.warn(`Integration Missing Activity codes Appid ${this.app.id} locations ${JSON.stringify(this.app.business.locations)}` + __location);
                }
                fulfill(false);
                return;
            }
            // Build some WHERE statements from those codes
            const whereCombinations = Object.values(wcCodes).map(function(codeObj) {
                return `(\`ac\`.\`id\` = ${db.escape(codeObj.id)} AND \`inc\`.\`territory\` = ${db.escape(codeObj.territory)})`;
            });

            const policyEffectiveDate = moment(this.policy.effective_date).format(db.dbTimeFormat());

            // Query the database to get the corresponding codes
            let hadError = false;
            const sql = `
            SELECT
                ac.id,
                inc.state,
                inc.territory,
                inc.code,
                inc.sub,
                inc.result
            FROM clw_talage_activity_codes AS ac
            LEFT JOIN clw_talage_activity_code_associations AS aca ON ac.id = aca.code
            LEFT JOIN clw_talage_insurer_ncci_codes AS inc ON aca.insurer_code = inc.id
            WHERE
                inc.insurer = ${this.insurer.id} 
                AND (${whereCombinations.join(' OR ')})
                AND ('${policyEffectiveDate}' >= inc.effectiveDate AND '${policyEffectiveDate}' < inc.expirationDate);
            `;
            const appId = this.app.id;
            const insurerId = this.insurer.id;
            const codes = await db.query(sql).catch((error) => {
                log.error(`AppId: ${appId} InsurerId: ${insurerId} Could not retrieve industry codes: ${error} ${__location}`);
                hadError = true;
            });
            if (hadError) {
                // Query error
                fulfill(false);
                return;
            }

            // Make sure the number of codes matched (otherwise there were codes unsupported by this insurer or a bad mapping.)
            if (this.requiresInsurerActivityClassCodes && (!codes.length || Object.keys(wcCodes).length !== codes.length)) {
                this.reasons.push("Insurer activity class codes were not found for all activities in the application.");
                log.warn(`AppId: ${appId} InsurerId: ${insurerId} _insurer_supports_activity_codes failed on application. query=${sql}` + __location);
                if(codes.length && codes.length > Object.keys(wcCodes).length){
                    log.error(`BAD MAPPING multiple insurer ncci codes for an activty Code - AppId: ${appId} InsurerId: ${insurerId} _insurer_supports_activity_codes failed on application. query=${sql}` + __location);
                }

                fulfill(false);
                return;
            }

            // Load the codes locally
            codes.forEach((code) => {
                if (code.result === 0) {
                    hadError = true;
                    return;
                }
                if (code.state) {
                    this.insurer_wc_codes[code.territory + code.id] = code.code + (code.sub ? code.sub : '');
                    return;
                }
                hadError = true;
            });
            if (hadError) {
                fulfill(false);
                return;
            }

            fulfill(true);
        });
    }

    /**
	 * Determines whether or not this insurer supports all industry codes in this application
     *
	 * @returns {Promise.<boolean>} A promise that returns an true if the insurer supports the industry code and it has been populated, false otherwise
	 */
    _insurer_supports_industry_codes() {
        return new Promise(async(fulfill) => {
            // append policy type if integration intends to use it
            let policyTypeWhere = '';
            if (this.requiresProductPolicyTypeFilter && this.policyTypeFilter) {
                policyTypeWhere = ` AND iic.policyType = '${this.policyTypeFilter}' `;
            }

            const policyEffectiveDate = moment(this.policy.effective_date).format(db.dbTimeFormat());

            // Query the database to see if this insurer supports this industry code
            let sql = `SELECT ic.id, ic.description, ic.cgl, ic.sic, ic.hiscox, ic.naics, ic.iso, iic.code, iic.description, iic.attributes 
                        FROM clw_talage_industry_codes AS ic 
                        INNER JOIN industry_code_to_insurer_industry_code AS industryCodeMap ON industryCodeMap.talageIndustryCodeId = ic.id
                        INNER JOIN clw_talage_insurer_industry_codes AS iic ON iic.id = industryCodeMap.insurerIndustryCodeId
                        WHERE
                            ic.id = ${this.app.applicationDocData.industryCode}
                            AND iic.insurer = ${this.insurer.id} 
                            AND iic.territory = '${this.app.applicationDocData.mailingState}'
                            AND ('${policyEffectiveDate}' >= iic.effectiveDate AND '${policyEffectiveDate}' < iic.expirationDate)
                            ${policyTypeWhere}
                            LIMIT 1;`
            let hadError = false;
            let result = await db.query(sql).catch((error) => {
                log.error(`AppId: ${this.app.id} InsurerId: ${this.insurer.id} Could not retrieve industry codes: ${error} ${__location}`);
                hadError = true;
            });
            if (hadError) {
                // Query error
                fulfill(false);
                return;
            }
            if (!result || !result.length) {
                if (this.requiresInsurerIndustryCodes) {
                    this.reasons.push("An insurer industry class code was not found for the given industry and territory.");
                    log.warn(`AppId: ${this.app.id} InsurerId: ${this.insurer.id} _insurer_supports_industry_codes required insurer mapping for this industry code was not found. query=${sql} ` + __location);
                    fulfill(false);
                    return;
                }
                // If insurer industry codes are not required, then still retrieve the industry code for the integration to use.
                sql = `
                    SELECT ic.id, ic.description, ic.cgl, ic.sic, ic.hiscox, ic.naics, ic.iso 
                    FROM clw_talage_industry_codes AS ic 
                    WHERE ic.id = ${this.app.applicationDocData.industryCode};
                `;
                hadError = false;
                result = await db.query(sql).catch((error) => {
                    log.error(`AppId: ${this.app.id} InsurerId: ${this.insurer.id} Could not retrieve industry codes: ${error} ${__location}`);
                    hadError = true;
                });
                if (hadError) {
                    // Query error
                    fulfill(false);
                    return;
                }
            }

            this.industry_code = result[0];

            // If there are attributes, parse them for later use
            if (this.industry_code.attributes && Object.keys(this.industry_code.attributes).length > 0) {
                try {
                    this.industry_code.attributes = JSON.parse(this.industry_code.attributes);
                }
                catch (error) {
                    log.error(`AppId: ${this.app.id} InsurerId: ${this.insurer.id} IndustryCode: ${this.app.applicationDocData.industryCode} Insurer industry code attributes could not be parsed: ${this.industry_code.attributes} ${__location}`);
                    this.industry_code.attributes = {};
                }
            }
            else {
                if (this.requiresInsurerIndustryCodes) {
                    log.warn(`Appid: ${this.app.id} No Industry_code attributes for ${this.insurer.name}:${this.insurer.id} and ${this.app.applicationDocData.mailingState}` + __location);
                }
                this.industry_code.attributes = {};
            }

            fulfill(true);
        });
    }
};
