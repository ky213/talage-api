/* eslint-disable no-trailing-spaces */
/* eslint-disable brace-style */
/* eslint-disable no-extra-parens */
/**
 * Defines a insurer integration
 */

'use strict';

const fileSvc = global.requireShared('./services/filesvc.js');
const htmlentities = require('html-entities').Html5Entities;
const https = require('https');
const moment = require('moment');
const util = require('util');
const {v4: uuidv4} = require('uuid');
const xmlToObj = util.promisify(require('xml2js').parseString);
const xmlFormatter = require('xml-formatter');
global.requireShared('./helpers/tracker.js');
const utility = global.requireShared('./helpers/utility.js');
const jsonFunctions = global.requireShared('./helpers/jsonFunctions.js');

// eslint-disable-next-line object-curly-newline
const {quoteStatus, getQuoteStatus, convertToAggregatedStatus} = global.requireShared('./models/status/quoteStatus.js');

const QuestionBO = global.requireShared('./models/Question-BO.js');
const QuoteBO = global.requireShared('./models/Quote-BO.js');


module.exports = class Integration {

    /**
     * Constructor for each integration
     *
     * @param {Application} app - An object containing all of the application information
     * @param {object} insurer - An object containing all of the insurer information
     * @param {object} policy - The data related to the current policy
     * @param {uuid} quoteId - This there is already an open quote.
     * @returns {void}
     */
    constructor(app, insurer, policy, quoteId) {
        // Integration flags

        // requiresInsurerIndustryCodes:
        //      - set to true if the integration has insurer industry codes.
        //      - set to false if the integration does not have insurer industry codes.
        this.requiresInsurerIndustryCodes = false;

        // requiresInsurerActivityClassCodes:
        //      - set to true if the integration has insurer activity class codes.
        //      - set to false if the integration does not have insurer activity class codes.
        this.requiresInsurerActivityClassCodes = false;

        // requiresProductPolicyTypeFilter:
        //      - set to true if the policy type must be used to filter industry codes.
        //      - if set to true, set the policyTYpeFilter to the string policy type (f.e. 'GL')
        this.requiresProductPolicyTypeFilter = false;
        this.policyTypeFilter = null;

        // Integration Data
        this.app = app;
        //this.industry_code is combination of Talage industrycode and insurer industry code.
        this.industry_code = {};
        this.insurerIndustryCode = {};

        this.insurer = insurer;
        this.insurerDoc = null;//mongo document for insurer.
        this.insurer_wc_codes = {};
        this.grouped_activity_codes = [];
        this.limits = {};
        this.quoteCoverages = [];
        this.log = '';
        //This is the quote number/id from
        this.number = '';
        this.policy = policy;
        this.questions = {};
        this.question_identifiers = {};
        this.question_details = {};
        this.request_id = '';
        this.seconds = 0;
        this.universal_questions = [];
        this.insurerQuestionList = []; //insurerQuestionModel
        this.writer = '';
        // These are set in our insurer integration
        this.possible_api_responses = {};

        // These are generated by our insurer integration
        this.quoteLink = '';
        this.quoteResponseJSON = null;
        this.deductible = null;
        this.amount = 0;
        this.quote_letter = {};
        this.reasons = [];
        this.quoteId = null;
        this.isBindable = false;
        this.insurerPaymentPlans = null;
        this.insurerPolicyInfo = null;


        // quoteId will be passed in if a parent integration was instantiated first and passes its quoteId through
        // Examples are Accident Fund and Liberty Mutual BOP
        if (quoteId) {
            this.quoteId = quoteId;
        }

        // Initialize the integration
        if (typeof this._insurer_init === "function") {
            try {
                this._insurer_init();
            }
            catch (err) {
                log.error('Integration insurer')
            }
        }

        // Apply WC payroll caps for Nevada
        if (this.policy.type === 'WC' && this.app.business && app.business.primary_territory === 'NV') {
            const nv_payroll_cap = 36000;

            // Loop through each location
            app.business.locations.forEach(function(location, location_index) {
                // Total the employees
                const total_employees = location.full_time_employees + location.part_time_employees;

                // Loop through each class code
                location.activity_codes.forEach(function(code, code_index) {
                    // If the payroll is over the cap, set it to the cap
                    if (code.payroll / total_employees > nv_payroll_cap) {
                        app.business.locations[location_index].activity_codes[code_index].payroll = nv_payroll_cap * total_employees;
                    }
                });
            });
        }
    }


    /* Standardized log messages */

    /**
     * Returns a standard integration logging string in the format of:
     *  Appid: APPLICATION_ID INSURER_NAME (INSURER_ID) POLICY_TYPE: MESSAGE LOCATION
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {string} - the standard formatted string
     */
    log_message(message, location, extraData = null) {
        let logMessage = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type}: ${message}`;
        // Append extra data
        if (extraData) {
            Object.keys(extraData).forEach((key) => {
                logMessage += `, ${key}=${extraData[key]}`;
            });
        }
        // Append the location
        if (location) {
            logMessage += ' ' + location;
        }
        return logMessage;
    }

    /**
     * Logs the message and location to the debug log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_debug(message, location, extraData = null) {
        log.debug(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the verbose log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_verbose(message, location, extraData = null) {
        log.verbose(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the info log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_info(message, location, extraData = null) {
        log.info(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the warn log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_warn(message, location, extraData = null) {
        log.warn(this.log_message(message, location, extraData));
    }

    /**
     * Logs the message and location to the error log
     *
     * @param {string} message - the message to log
     * @param {string} location - the location of the error
     * @param {Object} extraData - key/values that will be appended to the log message in form of 'key=value, key=value' (optional)
     * @returns {null}}
     */
    log_error(message, location, extraData = null) {
        log.error(this.log_message(message, location, extraData));
    }

    /**
     * Retrieves an insurer-specific NCCI code for a given activity code
     *
     * @param {number} insurerId - The insurer ID
     * @param {string} territory - The 2 character territory code
     * @param {number} activityCodeId - The Talage activity code
     * @returns {number} The 4 digit NCCI code
     */
    async get_insurer_code_for_activity_code(insurerId, territory, activityCodeId) {

        const policyEffectiveDate = moment(this.policy.effective_date);
        const InsurerActivityCodeModel = require('mongoose').model('InsurerActivityCode');
        const activityCodeQuery = {
            insurerId: insurerId,
            talageActivityCodeIdList: parseInt(activityCodeId,10),
            territoryList: territory,
            effectiveDate: {$lte: policyEffectiveDate},
            expirationDate: {$gte: policyEffectiveDate},
            active: true
        }
        let insurerActivityCode = {attributes: {}};
        try{
            insurerActivityCode = await InsurerActivityCodeModel.findOne(activityCodeQuery).lean()
            if(!insurerActivityCode){
                log.error(`Appid: ${this.app.id} get_insurer_code_for_activity_code Did not Find iac for ${this.insurer.name}:${this.insurer.id},  ${this.app.applicationDocData.mailingState} TalageActivtyCodeId ${activityCodeId}  query ${JSON.stringify(activityCodeQuery)}` + __location);
                insurerActivityCode = {attributes: {}};
            }
            if(typeof insurerActivityCode.attributes === 'string'){
                insurerActivityCode.attributes = JSON.parse(insurerActivityCode.attributes);
            }
        }
        catch(err){
            log.error(`Appid: ${this.app.id} Error get_insurer_code_for_activity_code for ${this.insurer.name}:${this.insurer.id},  ${this.app.applicationDocData.mailingState} TalageActivtyCodeId ${activityCodeId}  query ${JSON.stringify(activityCodeQuery)}  error ${err}` + __location);
        }
        return insurerActivityCode;

    }

    /**
     * Retrieves a national NCCI code from a given activity code
     *
     * @param {string} territory - The 2 character territory code
     * @param {number} activityCode - The 4 digit Talage activity code
     * @returns {object} The code and sub(code)
     */
    async get_national_ncci_code_from_activity_code(territory, activityCode) {
        // Retrieve a national NCCI code.
        // NOTE: we do not currently have these mapped but are in process; Adam is getting them.
        // Using Markel bigger set of codes than Liberty if liberty fails
        // Liberty codes mostly follow the national NCCI code numbering and we have most Liberty codes
        // mapped. So we use the Liberty code mapping for now until we have an official map of the
        // national NCCI codes. 
        const LibertyInsurerId = 14;
        const MarkelInsurerId = 3
        const libertyRecord = await this.get_insurer_code_for_activity_code(LibertyInsurerId, territory, activityCode);
        if (!libertyRecord) {
            const MarkelRecord = await this.get_insurer_code_for_activity_code(MarkelInsurerId, territory, activityCode);
            if (MarkelRecord) {
                return MarkelRecord.code;
            }
            else {
                return null;
            }
        }
        return libertyRecord.code;
    }

    /**
     * Returns an XML node child from parsed XML data. It will iterate down the node children, getting element 0 of each node's child.
     *
     * @param {object} node - top-level parent node
     * @param {Array} children - A dot-separated string of XML node names
     * @param {bool} returnRawLastNode - true if the returned child should be raw (NOT element zero of its node). Good if you want to iterate on the child node.
     * @returns {object} - Claims information lumped together by policy year
     */
    get_xml_child(node, children, returnRawLastNode = false) {
        const childrenList = children.split('.');
        let rawNode = node;
        for (const child of childrenList) {
            if (!node[child]) {
                return null;
            }
            rawNode = node[child];
            if (Array.isArray(rawNode)) {
                if (!rawNode.length) {
                    return null;
                }
                node = rawNode[0];
            }
            else {
                node = rawNode;
            }
        }
        return returnRawLastNode ? rawNode : node;
    }

    /**
     * Returns an object that includes Claims information based on policy years for up to the past 5 years
     *
     * @returns {object} - Claims information lumped together by policy year
     */
    claims_to_policy_years() {
        const claims = {};

        // Get the effective date of the policy
        const effective_date = this.policy.effective_date.clone();

        // Fill the claims object with some default data (for the policy year, year 1 is within effective date - 1 year, year 2 within 2 years, etc.)
        for (let i = 1; i <= 5; i++) {
            const c = {};
            c.amountPaid = 0;
            c.amountReserved = 0;
            c.count = 0;
            c.zeroPaidCount = 0;
            c.nonzeroPaidCount = 0;
            c.effective_date = effective_date.clone().subtract(i, 'years');
            c.expiration_date = c.effective_date.clone().add(1, 'years');
            c.missedWork = 0;
            claims[i] = c;
        }

        // Loop through each claim and add them to the claims object
        this.policy.claims.forEach((claim) => {
            // Determine the policy year
            let year = 0;
            for (let i = 1; i <= 5; i++) {
                if (claim.date.isAfter(this.policy.effective_date.clone().subtract(i, 'years'))) {
                    year = i;
                    break;
                }
            }

            // Make sure the claim was within the last 5 years
            if (!year) {
                return;
            }

            // Process this claim
            claims[year].amountReserved += claim.amountReserved;
            claims[year].amountPaid += claim.amountPaid;
            claims[year].count++;
            if (claim.missedWork) {
                claims[year].missedWork++;
            }
            if (claim.amountReserved || claim.amountPaid) {
                claims[year].nonzeroPaidCount++;
            }
            else {
                claims[year].zeroPaidCount++;
            }
        });

        return claims;
    }

    /**
     * Uses the activity codes from a single location combined with the insurer's specific NCCI codes to detect and combine any duplicates.
     *
     * @param {object} location - A single Location object
     * @returns {object} - The activity codes from within the location with any duplicates combined as code -> payroll pairs
     */
    combineLocationActivityCodes(location) {
        const returnCodes = {};
        location.activity_codes.forEach((activityCode) => {
            // Get the insurer's code for this activity
            const insurerCode = this.insurer_wc_codes[location.territory + activityCode.id];

            // Check if this code was already found
            if (Object.prototype.hasOwnProperty.call(returnCodes, insurerCode)) {
                // Combine the payroll
                returnCodes[insurerCode] += activityCode.payroll;
                return;
            }

            // This is a new one
            returnCodes[insurerCode] = activityCode.payroll;
        });

        return returnCodes;
    }

    /**
     * Determines the governing activity code for an application and returns the result.
     * The governing class code is determined by taking the activity code with the highest payroll. If there are two, the first code is used.
     * If the highest payroll code is our clerical code, it is ignored and the next highest is taken.
     *
     * @returns {object} - An ActivityCode object
     */
    determine_governing_activity_code() {
        // Group the activity codes
        this.group_activity_codes();

        // If there are not at least 2 activity codes, just return what we have
        if (this.grouped_activity_codes.length < 2) {
            return this.grouped_activity_codes[0];
        }

        // Sort the activity codes based on payroll
        this.grouped_activity_codes.sort(function compare(a, b) {
            if (a.payroll > b.payroll) {
                return -1;
            }
            if (a.payroll < b.payroll) {
                return 1;
            }
            return 0;
        });

        // Check if the highest payroll is our clerical code
        if (this.grouped_activity_codes[0].id === 2869) {
            // The highest payroll was clerical, reutrn the next highest instead
            return this.grouped_activity_codes[1];
        }
        // It wasn't clerical, return the highest payroll
        return this.grouped_activity_codes[0];
    }

    /**
     * Determines the proper answer to send to the insurer based on the question type. Return false if the question should be skipped.
     *
     * @param {object} question - A question object
     * @param {boolean} required - Whether or not this question is required by the insurer
     * @returns {mixed} - The answer to send to the insurer, or false if the question should be omitted
     */
    determine_question_answer(question, required) {
        let answer = false;

        // Default required
        required = required ? required : false;

        // Determine if the question is visible (its ancestors are all visible)
        let questionWasAnswered = true;
        let childQuestionId = question.id;
        while (this.questions.hasOwnProperty(childQuestionId) && this.questions[childQuestionId].parent !== 0) {
            // Get the parent ID. Ensure it is a string since the questions keys are strings.
            const parentQuestionId = this.questions[childQuestionId].parent;
            // Determine if the child question is visible
            if (!this.questions.hasOwnProperty(parentQuestionId) || this.questions[childQuestionId].parent_answer !== this.questions[parentQuestionId].answer_id) {
                questionWasAnswered = false;
                break;
            }
            childQuestionId = parentQuestionId;
        }
        // If not required and not answered, we return no answer
        if (!required && !questionWasAnswered) {
            return false;
        }

        // If this question has a parent that belongs to a different insurer it should have a default
        if (question.parent && !Object.prototype.hasOwnProperty.call(this.questions, question.parent) && question.answer_id === 0 && question.answer === null) {
            log.error(`Appid: ${this.app.id} Insurer: ${this.insurer.name} Question ${question.id} is missing a default answer. Defaulted to 'No' for this application. May cause quoting inaccuracies!` + __location);
            return 'No';
        }

        // If this is a checkbox, process each possible answer
        if (question.type === 'Checkboxes') {
            const answers = [];

            // Ensure the answers are an array
            if (Array.isArray(question.answer)) {
                // Loop over each possible answer
                for (let answer_id of question.answer) {
                    // Make sure the answer is permitted

                    // Ensure that the answer_id is a string, not a number.
                    // Note: on AWS servers, answer_id is a number; on other platforms, it is a string.
                    if (typeof answer_id !== "string") {
                        try {
                            answer_id = answer_id.toString();
                        }
                        catch (error) {
                            log.error(`Could not convert answer_id value ${answer_id} (type ${typeof answer_id}) to a string. Using original value.`);
                        }
                    }

                    if (!Object.prototype.hasOwnProperty.call(question.possible_answers, answer_id)) {
                        // This shouldn't have happened, throw an error
                        log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} question ${question.id} encountered an answer to a question that is not possible. This should have been caught in the validation stage.` + __location);
                        log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} question ${question.id} the question with not possible answer is as follows:\n ${util.inspect(question, false, null)} `);
                        return false;
                    }

                    // Add the answer to the answers array
                    answers.push(question.possible_answers[answer_id].answer);
                }
                // Return the answers as a comma separated string
                answer = answers.join(', ');
            }
            else {
                answer = '';
            }
            // If this is a Boolean or Select List question, get the answer expected by the carrier
        }
        else if (question.type === 'Yes/No' || question.type === 'Select List') {
            // Determine the answer based on the Answer ID stored in our database
            if (!Object.prototype.hasOwnProperty.call(question.possible_answers, question.answer_id)) {
                // This shouldn't have happened, throw an error
                log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} question ${question.id} encountered an answer to a question that is not possible. This should have been caught in the validation stage.` + __location);
                log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} question ${question.id} the question with not possible answer is as follows:\n ${util.inspect(question, false, null)} `);
                return false;
            }

            answer = question.possible_answers[question.answer_id].answer;
        }
        else {
            // This is a fill-in-the-blank style question, simply send what the user gave us
            answer = question.answer;
        }

        return answer;
    }

    /**
     * Determines the best limits available from the carrier. If no limits are suitable, returns false.
     *
     * @param {array} carrierLimits - A list of limits supported by the carrier
     * @returns {array|boolean} - An array containing limit values as integers, or false if none apply
     */
    getBestLimits(carrierLimits) {
        let higherLimit = null;

        // Take the requested limits and prepare them for processing
        const requestedLimits = this.getSplitLimits(this.policy.limits);

        // Prepare carrier limits for processing
        // eslint-disable-next-line prefer-const
        let splitCarrierLimitArray = carrierLimits.map(limit => this.getSplitLimits(limit));

        // Sort the limits by 1st, 2nd, then 3rd figure ascending to get the correct ordering
        splitCarrierLimitArray.sort((limit1, limit2) => limit1[0] - limit2[0]);
        splitCarrierLimitArray.sort((limit1, limit2) => limit1[1] - limit2[1]);
        splitCarrierLimitArray.sort((limit1, limit2) => limit1[2] - limit2[2]);

        // Some carriers support fewer than 3 limites. So we keep track of the "best" for 1, 2, or 3 limits
        // to allow fallback.
        let matchCount = 0;

        // Loop through all supported limits
        splitCarrierLimitArray.forEach((limitSet) => {
            if (limitSet[0] >= requestedLimits[0] && limitSet[1] >= requestedLimits[1] && limitSet[2] >= requestedLimits[2] && matchCount < 3) {
                higherLimit = limitSet;
                matchCount = 3;
            }
            else if (limitSet[0] >= requestedLimits[0] && limitSet[1] >= requestedLimits[1] & matchCount < 2) {
                higherLimit = limitSet;
                matchCount = 2;
            }
            else if (limitSet[0] >= requestedLimits[0] && matchCount < 1) {
                higherLimit = limitSet;
                matchCount = 1;
            }
        });

        return higherLimit;
    }

    /**
     * Returns the key (property) of an object based on the value of that property
     *
     * @param {object} obj - The object to search
     * @param {mixed} val - The value to find
     * @returns {string} - The key that matches
     */
    get_key_by_value(obj, val) {
        return Object.keys(obj).find((key) => obj[key] === val);
    }

    /**
     * Returns a description of the operations of the company based on the class codes they selected
     *
     * @returns {string} - The description of the business
     */
    get_operation_description() {
        return `${this.app.business.name} is a(n) ${this.app.business.industry_code_description.replace('&', 'and')} company with operations primarily located in ${this.app.business.locations[0].city}, ${this.app.business.locations[0].territory}.`;
    }

    /**
     * Gets the number of unique activity codes were included in this application
     *
     * @returns {int} - The number of activity codes
     */
    get_num_activity_codes() {
        // Group the activity codes
        this.group_activity_codes();

        // Return the count
        return this.grouped_activity_codes.length;
    }

    /**
     * Returns the number of claims that were within the number of years specified
     *
     * @param {int} number_of_years - The number of years of claims to total
     * @returns {int} - the number of claims
     */
    get_num_claims(number_of_years) {
        // Get the claims data organized by year
        const claims_by_year = this.claims_to_policy_years();

        // Loop through each year of claims
        let num_claims = 0;
        for (const claim_year in claims_by_year) {
            if (Object.prototype.hasOwnProperty.call(claims_by_year, claim_year)) {
                if (claim_year <= number_of_years) {
                    num_claims += claims_by_year[claim_year].count;
                }
            }
        }

        // Return the result
        return num_claims;
    }

    /**
     * Gets the details for each question for the current insurer. These details include the attributes, identifier, and whether or not the question is universal
     *
     * @returns {Promise.<object, Error>} A promise that returns an object containing objects indexed on the Talage Question ID with question information specific to this insurer if resolved, or an Error if rejected
     */
    async get_question_details() {
        const results = await this.getInsurerQuestionsByTalageQuestionId("general", Object.keys(this.questions));
        //To Allow for multiple iq => Talage question mappings.
        //use app.questions insurerQuestionRefList to make sure there guestions that generated the Talage question.
        //  for (const question_id in this.app.questions) {
        //const question = this.app.questions[question_id];
        // if(question.insurerQuestionRefList){
        //  }

        // Convert this into an object for easy reference
        const question_details = {};
        try {

            results.forEach((result) => {
                try{
                    question_details[result.question] = {
                        insurerQuestionId: result.id,
                        attributes: result.attributes ? result.attributes : '',
                        identifier: result.identifier,
                        universal: result.universal
                    };
                    if (result.universal) {
                        this.universal_questions.push(result.question);
                    }
                }
                catch(err){
                    log.error(`Question details ${JSON.stringify(result)}: ` + err + __location);
                }
            });
        }
        catch (err) {
            log.error('Question details: ' + err + __location);
        }
        return question_details;
    }

    /**
     * Get insurer questions for given talage questions 
     *
     * @param {string} questionSubjectArea - The question subject area ("general", "location", ...) Default is "general".
     * @param {Array} talageQuestionIdList - Array of Talage question IDs
     * @returns {Promise.<object, Error>} A promise that returns an object containing question information if resolved, or an Error if rejected
     */
    async getInsurerQuestionsByTalageQuestionId(questionSubjectArea, talageQuestionIdList) {
        if (talageQuestionIdList.length > 0) {
            
            talageQuestionIdList = talageQuestionIdList.map(Number)
            const query = {
                "insurerId": this.insurer.id,
                "questionSubjectArea": questionSubjectArea,
                "talageQuestionId": {$in: talageQuestionIdList}
            }
            const InsurerQuestionModel = require('mongoose').model('InsurerQuestion');
            let insurerQuestionListSA = null;
            try{
                insurerQuestionListSA = await InsurerQuestionModel.find(query);
            }
            catch(err){
                throw err
            }
            insurerQuestionListSA.forEach((insurerQuestion) => {
                insurerQuestion.question = insurerQuestion.talageQuestionId;
                insurerQuestion.id = insurerQuestion.insurerQuestionId;
            });
            return insurerQuestionListSA;
        }
        else {
            return [];
        }
    }


    /**
     * Retrieves the application's  ActivityCodeIds
     *
     * @returns {array} - Array of Talage ActivityCodeId
     */
    get_application_activitycodes(){
        const activityCodeArray = [];
        this.app.applicationDocData.locations.forEach(function(location) {
            location.activityPayrollList.forEach(function(activtyCodePayroll) {
                if(!activityCodeArray.activityCodeId){
                    activityCodeArray.activityCodeId = activityCodeArray.ncciCode
                }
                if(!activityCodeArray.includes(activtyCodePayroll.activityCodeId)){
                    activityCodeArray.push(activtyCodePayroll.activityCodeId)
                }
            });
        });
        return activityCodeArray;

    }

    /**
     * Retrieves the application's  ActivityCodeIds
     *
     * @returns {array} - Array of Talage ActivityCodeId
     */
    get_application_territorylist(){
        const territoryList = [];
        this.app.applicationDocData.locations.forEach(function(location) {
            if(!territoryList.includes(location.state)){
                territoryList.push(location.state)
            }
        });
        return territoryList;

    }

    /**
     * Retrieves the applications  Array of Talage ActivityCodeId
     *
     * @param {string} activityCodeArray - Array of Talage ActivityCodeId
     * @returns {array} - Array of Insurer Questions
     */
    async get_insurer_questions_by_activitycodes(activityCodeArray){
        if(!activityCodeArray){
            activityCodeArray = this.get_application_activitycodes();
        }
        if (activityCodeArray.length > 0) {
            const territoryList = this.get_application_territorylist();
            //Find insurerActivityCode
            const InsurerActivityCodeModel = require('mongoose').model('InsurerActivityCode');
            const policyEffectiveDate = moment(this.policy.effective_date).format(db.dbTimeFormat());
            const activityCodeQuery = {
                insurerId: this.insurer.id,
                talageActivityCodeIdList: {$in: activityCodeArray},
                territoryList: {$in: territoryList},
                effectiveDate: {$lte: policyEffectiveDate},
                expirationDate: {$gte: policyEffectiveDate},
                active: true
            }
            let insurerQuestionList = null;
            try{
                // eslint-disable-next-line prefer-const
                let insurerQuestionIdList = [];
                const insurerActivityCodeList = await InsurerActivityCodeModel.find(activityCodeQuery).lean()
                insurerActivityCodeList.forEach((insurerActivtyCode) => {
                    let newInsurerQuestionList = [];
                    for(let i = 0; i < territoryList.length; i++){
                        const tQFound = insurerActivtyCode.insurerTerritoryQuestionList.find((tQ) => tQ.territory === territoryList[i]);
                        if(tQFound && tQFound.insurerQuestionIdList && tQFound.insurerQuestionIdList.length > 0){
                            newInsurerQuestionList = tQFound.insurerQuestionIdList
                            break;
                        }
                    }
                    if(newInsurerQuestionList.length === 0){
                        newInsurerQuestionList = insurerActivtyCode.insurerQuestionIdList
                    }
                    if(newInsurerQuestionList.length > 0){
                        utility.addArrayToArray(insurerQuestionIdList,newInsurerQuestionList)
                    }
                });

                const query = {
                    "insurerId": this.insurer.id,
                    "insurerQuestionId": {$in: insurerQuestionIdList}
                }
                const InsurerQuestionModel = require('mongoose').model('InsurerQuestion');
                try{
                    insurerQuestionList = await InsurerQuestionModel.find(query);
                }
                catch(err){
                    throw err
                }
            }
            catch(err){
                log.error(`Appid ${this.app.applicationDocData.applicationId} insurer ${this.insurer.id}: get_insurer_questions_by_activitycodes error ${err} ` + __location);
            }
            return insurerQuestionList;
        }
        else {
            return [];
        }

    }

    /**
     * Retrieves the question that matches the identifier specified, returns false if none
     *
     * @param {string} identifier - The insurer identifier for the question
     * @returns {mixed} - question object on success, false otherwise
     */
    get_question_by_identifier(identifier) {
        // Loop through each question and check the identifier
        for (const question_id in this.questions) {
            if (Object.prototype.hasOwnProperty.call(this.questions, question_id)) {
                if (this.question_identifiers[question_id] === identifier) {
                    return this.questions[question_id];
                }
            }
        }
        return false;
    }

    /**
     * Gets the identifiers for each question for the current insurer also populates also populates insurerQuestionList
     *
     * @returns {Promise.<object, Error>} A promise that returns an object containing question information if resolved, or an Error if rejected
     */
    get_question_identifiers() {
        return new Promise(async(fulfill) => {
            // Build an array of question IDs to retrieve
            const question_ids = Object.keys(this.questions);
            const talageQuestionIdList = question_ids.map(Number)

            if (question_ids.length > 0) {
                const query = {
                    "insurerId": this.insurer.id,
                    "talageQuestionId": {$in: talageQuestionIdList}
                }
                const InsurerQuestionModel = require('mongoose').model('InsurerQuestion');
                //let insurerQuestionList = null;
                try{
                    log.debug(`get_question_identifiers query ${JSON.stringify(query)}`)
                    this.insurerQuestionList = await InsurerQuestionModel.find(query);
                    if(this.insurerQuestionList && this.insurerQuestionList.length === 0){
                        log.warn(`Appid ${this.app.applicationDocData.applicationId} insurer ${this.insurer.id}: No insurerQuestionList ${JSON.stringify(query)}` + __location)
                    }
                }
                catch(err){
                    throw err
                }
                const identifiers = {};
                this.insurerQuestionList.forEach((insurerQuestion) => {
                    identifiers[insurerQuestion.talageQuestionId] = insurerQuestion.identifier;
                    if (insurerQuestion.universal) {
                        this.universal_questions.push(insurerQuestion.talageQuestionId);
                    }
                });
                // Return the mapping
                fulfill(identifiers);

            }
            else {
                log.warn(`Appid ${this.app.applicationDocData.applicationId} insurer ${this.insurer.id}: No question_ids ${JSON.stringify(this.questions)}` + __location);
                fulfill({});
            }
        });
    }

    /**
     * Splits a limits string into an array and coverts the values to integers
     *
     * @param {string} limits - A limits string
     * @returns {array} - An array of integers
     */
    getSplitLimits(limits) {
        return limits.split('/').map(function(val) {
            return parseInt(val, 10);
        });
    }

    /**
     * Returns the total incurred (paid + reserved) on claims that were within the number of years specified
     *
     * @param {int} number_of_years - The number of years of claims to total
     * @returns {int} - the number of claims
     */
    get_total_amount_incurred_on_claims(number_of_years) {
        // Get the claims data organized by year
        const claimsByYear = this.claims_to_policy_years();

        // Loop through each year of claims
        let total = 0;
        for (const year in claimsByYear) {
            if (Object.prototype.hasOwnProperty.call(claimsByYear, year)) {
                if (year <= number_of_years) {
                    total += claimsByYear[year].amountPaid;
                    total += claimsByYear[year].amountReserved;
                }
            }
        }

        // Return the result
        return total;
    }

    /**
     * Returns the total number of employees associated with this application
     *
     * @returns {int} - The total number of employees as an integer
     */
    get_total_employees() {
        let total = 0;
        //New more detailed info in AppDoc.
        this.app.applicationDocData.locations.forEach((appLocation) => {
            appLocation.activityPayrollList.forEach((activtyCodePayroll) => {
                activtyCodePayroll.employeeTypeList.forEach((employeeType) => {
                    total += employeeType.employeeTypeCount;
                });

            });
        });
        //Old simpler storage.
        if(total === 0){
            this.app.business.locations.forEach(function(loc) {
                total += loc.full_time_employees;
                total += loc.part_time_employees;
            });
        }
        return total;
    }

    /**
     * Returns the total number of full-time employees associated with this application
     *
     * @returns {int} - The total number of full-time employees as an integer
     */
    get_total_full_time_employees() {
        let total = 0;
        let totalLocLevel = 0;
        this.app.applicationDocData.locations.forEach(loc => {
            totalLocLevel += loc.full_time_employees;
            loc.activityPayrollList.forEach((activtyCodePayroll) => {
                activtyCodePayroll.employeeTypeList.forEach((employeeType) => {
                    if(employeeType.employeeType === "Full Time"){
                        total += employeeType.employeeTypeCount;
                    }
                });

            });
        });
        //handle if old style
        if(total === 0){
            total = totalLocLevel;
        }
        return total;
    }

    /**
     * Returns the total number of part-time employees associated with this application
     *
     * @returns {int} - The total number of part-time employees as an integer
     */
    get_total_part_time_employees() {
        let total = 0;
        let totalLocLevel = 0;
        this.app.applicationDocData.locations.forEach(loc => {
            totalLocLevel += loc.part_time_employees;
            loc.activityPayrollList.forEach((activtyCodePayroll) => {
                activtyCodePayroll.employeeTypeList.forEach((employeeType) => {
                    if(employeeType.employeeType === "Part Time"){
                        total += employeeType.employeeTypeCount;
                    }
                });

            });
        });
        //handle if old style
        if(total === 0){
            total = totalLocLevel;
        }
        return total;
    }

    /**
     * Returns the total payroll associated with this application
     *
     * @returns {int} - The total payroll as an integer
     */
    get_total_payroll() {
        let total = 0;
        //new more complex storage
        this.app.applicationDocData.locations.forEach((appLocation) => {
            appLocation.activityPayrollList.forEach((activtyCodePayroll) => {
                activtyCodePayroll.employeeTypeList.forEach((employeeType) => {
                    total += employeeType.employeeTypePayroll;
                });

            });
        });
        //Old  simple by activity code only storage
        if(total === 0){
            this.app.business.locations.forEach(loc => {
                loc.activity_codes.forEach(wc_code => {
                    total += wc_code.payroll;
                });
            });
        }
        return total;
    }

    /**
     * Returns the total square footage of locations associated with this application
     *
     * @returns {int} - The total square footage as an integer
     */
    get_total_square_footage() {
        let total = 0;
        this.app.business.locations.forEach(function(loc) {
            total += loc.square_footage;
        });
        return total;
    }

    /**
     * Returns the number of years this business has operated
     *
     * @returns {int} - The total number of years in business
     */
    get_years_in_business() {
        // not correct for Employers Feb 2021.
        //return moment().diff(this.app.business.founded, 'years');
        if(this.app.applicationDocData.founded){
            return moment().diff(this.app.applicationDocData.founded, 'years');
        }
        else {
            return 0;
        }
    }

    /**
     * Returns the years since the last claim was filed. If claims were never filed, returns 999
     *
     * @returns {int} - The total number of years
     */
    get_years_since_claim() {
        if (!this.policy.claims.length) {
            return 999;
        }

        let years_ago = 999;
        this.policy.claims.forEach((claim) => {
            const num_years = moment().diff(claim.date, 'years');
            if (num_years < years_ago) {
                years_ago = num_years;
            }
        });
        return years_ago;
    }

    /**
     * Generates and returns a Version 4 UUID
     * Note: Version 4 UUIDs are completely random where Version 5 are not.
     *
     * @returns {string} - A random 36 character UUID formatted as follows 1f16f5d4-629b-11e7-b786-54616c616765
     */
    generate_uuid() {
        return uuidv4();
    }

    /**
     * Finds every activity code in an application and groups them together, adding their payrolls. Stores the result locally for later use.
     *
     * @returns {object} - An object with keys that are activity code ids, and values that are combined payrolls.
     */
    group_activity_codes() {
        // If this function has already run, simply return what we already determined
        if (this.grouped_activity_codes.length) {
            return this.grouped_activity_codes;
        }

        // First, localize all activity codes
        const activity_codes = [];

        // Get codes from all locations
        this.app.business.locations.forEach((location) => {
            // Loop through each code in this location
            location.activity_codes.forEach((activity_code) => {
                // Check if we have aleady seen this code on another location
                let seen = false;
                activity_codes.forEach((code, index) => {
                    if (activity_code.id === code.id) {
                        seen = true;

                        // Comine the payrolls for this code
                        activity_codes[index].payroll += activity_code.payroll;
                    }
                });

                if (!seen) {
                    // This is a new code, add it to our list
                    activity_codes.push(activity_code);
                }
            });
        });

        // Store the results locally for later use
        this.grouped_activity_codes = activity_codes;

        return activity_codes;
    }

    /**
     * An entry point for getting quotes that conducts some necessary pre-processing before calling the insurer_quote function.
     *
     * @returns {Promise.<object, Error>} A promise that returns an object containing quote information if resolved, or an Error if rejected
     */
    quote() {
        log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Quote Started (mode: ${this.insurer.useSandbox ? 'sandbox' : 'production'})`);
        return new Promise(async(fulfill) => {

            if (!this.quoteId) {
                this.quoteId = await this.record_quote(null, quoteStatus.initiated.description);
            }

            // Get the credentials ready for use
            this.password = await this.insurer.get_password();
            this.username = await this.insurer.get_username();

            // Make sure expiration_date is set
            if (this.policy && (!this.policy.expiration_date || !this.policy.expiration_date.isValid())) {
                log.warn(`Appid: ${this.app.id} Application ${this.app.id} policy had an invalid effective date. Setting it to 1 years after effective date. ${__location}`);
                this.policy.expiration_date = this.policy.effective_date.clone().add(1, 'years');
            }

            // Make sure the insurer_quote() function exists
            if (typeof this._insurer_quote === 'undefined') {
                const error_message = `Appid: ${this.app.id} Insurer: ${this.insurer.name} Integration file must include the insurer_quote() function`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                fulfill(this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.'));
                return;
            }

            // Check for outage - "outages" in Insurer class and database SQL
            if (this.insurer.outage) {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} is currently unavailable to planned outage`;
                this.reasons.push(error_message);
                fulfill(this.return_error('outage'));
                return;
            }

            // Check that industry codes codes are supported by the insurer if required
            if (!await this._insurer_supports_industry_codes() && this.requiresInsurerIndustryCodes) {
                // No industry codes when they are required
                fulfill(this.client_autodeclined_out_of_appetite());
                return;
            }

            // Check that activity class codes codes are supported by the insurer if required
            if (!await this._insurer_supports_activity_codes() && this.requiresInsurerActivityClassCodes) {
                // No activity class codes when they are required
                fulfill(this.client_autodeclined_out_of_appetite());
                return;
            }

            // Localize the questions and restrict them to only ones that are applicable to this insurer and policy type
            let insurerQuestionList = null;
            const query = {
                "insurerId": this.insurer.id,
                "policyTypeList": this.policy.type
            }
            const InsurerQuestionModel = require('mongoose').model('InsurerQuestion');
            try{
                insurerQuestionList = await InsurerQuestionModel.find(query);
            }
            catch(err){
                log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type}: error getting insurerQuestionList ${err}` + __location)
            }
            for (const question_id in this.app.questions) {
                if (Object.prototype.hasOwnProperty.call(this.app.questions, question_id)) {
                    try{
                        const question = this.app.questions[question_id];
                        if(insurerQuestionList){
                            const iQFound = insurerQuestionList.find((iq) => iq.talageQuestionId === parseInt(question_id,10));
                            if(iQFound){
                                this.questions[question_id] = question;
                            }
                        }
                    }
                    catch(err){
                        log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type}: error get question ${question_id} for ${this.insurer.id}-${this.policy.type} ` + __location)
                    }
                }
            }


            // Get the insurer question identifiers
            let stop = false;
            this.question_details = await this.get_question_details().catch((error) => {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get question details. ${error}`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                //Do not want to stop the rest of the quoting for application.
                // and end of quoting processing.
                //reject(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                stop = true;
            });
            this.question_identifiers = await this.get_question_identifiers().catch((error) => {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get question identifiers. ${error}`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                //Do not want to stop the rest of the quoting for application.
                // and end of quoting processing.
                //reject(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                stop = true;
            });
            if (stop) {
                return;
            }

            // ========================================================================================================================
            // Filter the application questions to remove hidden qustions, unanswered questions, and question for other carriers

            // Create a working copy of the applicationDocData just for this integration
            this.app.applicationDocData = jsonFunctions.jsonCopy(this.app.applicationDocData);

            // NOTE: filterApplicationQuestionListForInsurer will log its own errors

            // General questions
            const filteredGeneralQuestionList = await this.filterApplicationQuestionListForInsurer("general", this.app.applicationDocData.questions);
            if (!filteredGeneralQuestionList) {
                fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                return;
            }
            this.app.applicationDocData.questions = filteredGeneralQuestionList;

            // Location questions
            for (const location of this.app.applicationDocData.locations) {
                if (location.questions) {
                    const filteredLocationQuestionList = await this.filterApplicationQuestionListForInsurer("location", location.questions);
                    if (!filteredLocationQuestionList) {
                        fulfill(this.return_error('error', "We have no idea what went wrong, but we're on it"));
                        return;
                    }
                    location.questions = filteredLocationQuestionList;
                    // Building questions?
                    // Vehicle questions?
                }
            }

            // Run the quote
            const appId = this.app.id;
            const insurerName = this.insurer.name;
            const policyType = this.policy.type
            let error = null;
            const result = await this._insurer_quote().catch(function(err) {
                const error_message = `Appid: ${appId} ${insurerName} ${policyType} is unable to quote ${err}`;
                log.error(error_message + __location);
                error = err;
            });

            if(error){
                //need to save quote with reason.
                const error_message = `${insurerName} ${policyType} is unable to quote ${error}`;
                this.reasons.push(error_message)
                this.return_result('error');
                fulfill(null);
            }
            fulfill(result);
        });
    }

    /**
     * Filter the question list to remove hidden questions, unanswered questions, and question for other carriers
     * This function logs its own errors.
     *
     * @param {string} questionSubjectArea - The question subject area ("general", "location", ...) Default is "general".
     * @param  {Array} applicationQuestionList - The question list
     * @returns {Array} filtered question list or null if error (errors are logged)
     */
    async filterApplicationQuestionListForInsurer(questionSubjectArea, applicationQuestionList) {
        // Create an array of Talage question IDs
        const talageQuestionIdList = applicationQuestionList.map((aq) => aq.questionId);

        // Get the insurer questions for those Talage question IDs
        let insurerQuestionList = null;
        try {
            // Get the insurer question identifiers for the question subject area
            insurerQuestionList = await this.getInsurerQuestionsByTalageQuestionId(questionSubjectArea, talageQuestionIdList);
        }
        catch (error) {
            const error_message = `Unable to get "${questionSubjectArea}" question identifiers.`;
            log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} ${error_message}: ${error}` + __location);
            this.reasons.push(error_message);
            return null;
        }

        // Retrieve the Talage questions for the application questions so we can determine both the parent hierarchy and the parent_answer for a child question
        const questionBO = new QuestionBO();
        const talageQuestionList = [];
        for (const applicationQuestion of applicationQuestionList) {
            let talageQuestion = null;
            try {
                talageQuestion = await questionBO.getById(applicationQuestion.questionId);
            }
            catch (error) {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get Talage question ${applicationQuestion.questionId}. ${error}}`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return null;
            }
            if (talageQuestion) {
                talageQuestionList.push(talageQuestion);
            }
            else {
                // Could not find the talage question by ID
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} is unable to get Talage question ${applicationQuestion.questionId}: could not find ID.`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return null;
            }
        }

        const answeredApplicationQuestionList = [];

        // Remove non-answered questions.
        // This will walk all parents of a given application question up to the top-level question. If any of those parents
        // were answered in a way where it would not show the child (parent's answer != child's parent_answer), then the original
        // child was never asked and can be filtered out.
        for (const applicationQuestion of applicationQuestionList) {
            let questionWasAnswered = true;
            let childApplicationQuestion = applicationQuestion;
            let childTalageQuestion = talageQuestionList.find((tq) => tq.id === childApplicationQuestion.questionId);
            // While the question has a parent (not top-level)
            while (childTalageQuestion.parent) {
                // Find the parent application question for this child
                // eslint-disable-next-line no-loop-func
                const parentApplicationQuestion = applicationQuestionList.find((aq) => aq.questionId === childTalageQuestion.parent);
                if (!parentApplicationQuestion) {
                    questionWasAnswered = false;
                    break;
                }
                // Determine if the parent was answered such that the child became visible. If not, flag it and stop.
                if (childTalageQuestion.parent_answer && childTalageQuestion.parent_answer !== parentApplicationQuestion.answerId) {
                    questionWasAnswered = false;
                    break;
                }
                // Move up a question level (parent becomes child)
                // eslint-disable-next-line no-loop-func
                childTalageQuestion = talageQuestionList.find((tq) => tq.id === parentApplicationQuestion.questionId);
                childApplicationQuestion = parentApplicationQuestion;
            }
            // Add it to the filtered question list if the parent was answered
            if (questionWasAnswered) {
                answeredApplicationQuestionList.push(applicationQuestion);
            }
        }

        // Next we remove question for other insurers and hidden questions. This must be done AFTER we determine if a question was answered because
        // A parent question may be for another insurer (NOTE: that may lead to problems due to chicken/egg issue where an insurer's question
        // may be require but never asked because another the insurer's parent question was never answered -SF)
        const notHiddenInsurerApplicationQuestionList = [];
        for (const applicationQuestion of answeredApplicationQuestionList) {
            // Check if the application question is relevant to this insurer and isn't hidden. We do this by looking for the
            // Talage question ID in the insurer question list we retrieved above. If we find it, then this insurer asked it.
            const insurerQuestion = insurerQuestionList.find((iq) => iq.question === applicationQuestion.questionId);
            if (insurerQuestion && !applicationQuestion.hidden) {
                let insurerQuestionAttributes = null;
                if (insurerQuestion.attributes) {
                    try {
                        if(typeof insurerQuestion.attributes === 'string'){
                            insurerQuestionAttributes = JSON.parse(insurerQuestion.attributes);
                        }
                        else {
                            insurerQuestionAttributes = insurerQuestion.attributes;
                        }
                    }
                    catch (error) {
                        log.warn(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Could not parse attributes for insurer question ${insurerQuestion.identifier}`);
                    }
                }
                applicationQuestion.insurerQuestionIdentifier = insurerQuestion.identifier;
                applicationQuestion.insurerQuestionAttributes = insurerQuestionAttributes;
                notHiddenInsurerApplicationQuestionList.push(applicationQuestion);
            }
        }

        return notHiddenInsurerApplicationQuestionList;
    }

    /**
     * Records this quote in the database so we know it happened
     *
     * @param {int} amount - The amount of the quote
     * @param {string} apiResult - The integration's api result
     * @returns {mixed} - ID on success, error on error
     */
    async record_quote(amount, apiResult) {
        const appId = this.app.applicationDocData.applicationId
        const insurerName = this.insurer.name;
        const policyType = this.policy.type;


        //build mongo Document
        const quoteJSON = {
            applicationId: this.app.applicationDocData.applicationId,
            insurerId: this.insurer.id,
            log: this.log,
            policyType: this.policy.type,
            quoteTimeSeconds: this.seconds
        }
        // if this is a new quote, set its quotingStartedDate to now
        if (apiResult === quoteStatus.initiated.description) {
            quoteJSON.quotingStartedDate = moment.utc();
        }

        if(this.quoteResponseJSON){
            quoteJSON.quoteResponseJSON = this.quoteResponseJSON;
        }

        try{
            // Amount
            if (amount) {
                quoteJSON.amount = amount;
            }

            // Deductible
            if (this.deductible !== null) {
                quoteJSON.deductible = this.deductible;
            }

            // Number
            if (this.number) {
                quoteJSON.quoteNumber = this.number;
            }

            // Request ID
            if (this.request_id) {
                quoteJSON.requestId = this.request_id
            }

            // Writer
            if (this.writer) {
                quoteJSON.writer = this.writer
            }
            if(this.quoteLink){
                quoteJSON.quoteLink = this.quoteLink
            }
            if(this.isBindable){
                quoteJSON.isBindable = this.isBindable
            }

            if(this.insurerPaymentPlans){
                quoteJSON.insurerPaymentPlans = this.insurerPaymentPlans
            }
            if(this.insurerPolicyInfo){
                quoteJSON.policyInfo = this.insurerPolicyInfo
            }

            // Error
            quoteJSON.apiResult = apiResult

            // Reasons
            if (this.reasons.length > 0) {
                // Note: we do not need to escape apostrophes when going to Mongo. This was causing quote reasons to show an escape apostrophe in the agency portal -SF
                quoteJSON.reasons = this.reasons.join(',');
            }
        }
        catch(err){
            log.error(`AppId: ${appId} Insurer:  ${insurerName} : ${policyType} - record_quote error populating values. error ${err} ` + __location)
        }

        try{
            // Quote Letter
            if (this.quote_letter && Object.prototype.hasOwnProperty.call(this.quote_letter, 'data') && this.quote_letter.data) {
                // Generate a UUID to use as the file name
                const fileName = `${this.generate_uuid()}.pdf`;

                // Store the quote letter in our cloud storage
                try {
                    // Store the quote letter in our cloud storage
                    // Secure
                    const result = await fileSvc.PutFileSecure(`secure/quote-letters/${fileName}`, this.quote_letter.data);
                    // The file was successfully saved, store the file name in the database
                    if (result && result.code === 'Success') {
                        quoteJSON.quoteLetter = fileName
                    }
                }
                catch (err) {
                    log.error(`Appid: ${this.app.id} Insurer: ${this.insurer.name} S3 error Storing Quote letter: ${fileName}, error: ${err}. ${__location}`);
                }
            }
        }
        catch(err){
            log.error(`AppId: ${appId} Insurer:  ${insurerName} : ${policyType} - record_quote error saving qoute letter. error ${err} ` + __location)
        }
    
        // quoteStatusId and quoteStatusDescription
        const status = getQuoteStatus(false, '', apiResult);
        quoteJSON.quoteStatusId = status.id;
        quoteJSON.quoteStatusDescription = status.description;

        // backwards compatibility w/ old Mongo property and existing code logic
        try{
            quoteJSON.aggregatedStatus = convertToAggregatedStatus(status);
            // Aggregated Status (backwards compatibility w/ SQL)
        }
        catch(err){
            log.error(`AppId: ${appId} Insurer:  ${insurerName} : ${policyType} - record_quote error setting  aggregatedStatus. error ${err} ` + __location)
        }

        try{
            // Set up quote limits for old-style hydration (should be deprecated eventually)
            if (this.limits && Object.keys(this.limits).length) {
                // eslint-disable-next-line guard-for-in
                for (const limitId in this.limits) {
                    if (Object.prototype.hasOwnProperty.call(this.limits, limitId) && typeof this.limits[limitId] === 'number' && this.limits[limitId]) {
                        const limitJSON = {
                            limitId: limitId,
                            amount: this.limits[limitId]
                        };
                        if(!quoteJSON.limits){
                            quoteJSON.limits = [];
                        }
                        quoteJSON.limits.push(limitJSON);
                    }
                }
            }
        }
        catch(err){
            log.error(`AppId: ${appId} Insurer:  ${insurerName} : ${policyType} - record_quote error setting limits. values ${err} ` + __location)
        }
        // hydrate quoteCoverages property with insurer coverages
        if (this.quoteCoverages && this.quoteCoverages.length > 0) {
            quoteJSON.quoteCoverages = this.quoteCoverages;
        }

        try{
            //shouldNotifyTalage is based on talageWholesale Setting
            const notifiyTalageTest = this.app.agencyLocation.shouldNotifyTalage(quoteJSON.insurerId);
            //We only need one AL insurer to be set to notifyTalage to send it to Slack.
            if(notifiyTalageTest === true){
                quoteJSON.handledByTalage = true;
                quoteJSON.talageWholesale = true;
            }
        }
        catch(err){
            log.error(`AppId: ${appId} Insurer:  ${insurerName} : ${policyType} - record_quote error getting notifiyTalageTest. ${err} ` + __location)
        }
        //QuoteBO
        try{
            const quoteBO = new QuoteBO();
            this.quoteId = await quoteBO.saveIntegrationQuote(this.quoteId, quoteJSON).catch(function(err){
                log.error("Error quoteBO.saveIntegrationQuote " + err + __location);
            });
        }
        catch(err){
            log.error(`AppId: ${appId} Insurer:  ${insurerName} : ${policyType} - record_quote error saving quote. Error: ${err} ` + __location)
        }

        return this.quoteId;
    }

    /**
     * Returns a quote object for an auto-declined quote
     *
     * @param {string} publicMessage - Message to display to the customer
     * @param {Array} extraReasonList - Array of strings listing additional decline reasons
     * @returns {object} - An object containing the quote information
     */
    async client_declined(publicMessage = null, extraReasonList = null) {
        if (!publicMessage) {
            publicMessage = "The insurer has declined to offer you coverage at this time.";
        }
        this.reasons.push(publicMessage);
        if (extraReasonList) {
            for (const extraReason of extraReasonList) {
                this.reasons.push(extraReason);
            }
        }
        this.log_info(`Declined with message '${publicMessage}'`, __location, {extraReasonList: extraReasonList});
        return this.return_result('declined');
    }

    /**
     * Returns a quote object for an auto-declined quote
     *
     * @param {string} publicMessage - Message to display to the customer
     * @param {object} extraLogData - Data to append to the logging message
     * @returns {object} - An object containing the quote information
     */
    async client_autodeclined(publicMessage, extraLogData = null) {
        this.reasons.push(publicMessage);
        this.log_info(`Autodeclined with message '${publicMessage}'`, __location, extraLogData);
        return this.return_result('autodeclined');
    }

    /**
     * Returns a quote object for an auto-declined out of appetite quote
     *
     * @returns {object} - An object containing the quote information
     */
    async client_autodeclined_out_of_appetite() {
        return this.client_autodeclined('Out of Appetite: The insurer reports that they will not write a policy with the selected state and industry or activity code');
    }

    /**
     * Returns a quote object for a 'referred' quote
     *
     * @param {string} quoteNumber - The quote's number for the given insurer (optional, but encouraged)
     * @param {array<object>} limits - The limits parsed from the quote (optional if coverages is supplied)
     * @param {int} premiumAmount - The premium amount (optional)
     * @param {string} quoteLetter - The quote letter (optional)
     * @param {int} quoteLetterMimeType - Quote letter mime type (optional, default = "application/base64")
     * @param {array<object>} quoteCoverages - The insurer quote coverages parsed from the quote (optional if limits is supplied)
     * @returns {object} - An object containing the quote information
     */
    async client_referred(quoteNumber, limits = {}, premiumAmount = null, quoteLetter = null, quoteLetterMimeType = null, quoteCoverages = []) {
        this.limits = limits && Object.keys(limits).length > 0 ? limits : null;
        this.quoteCoverages = quoteCoverages && quoteCoverages.length > 0 ? quoteCoverages : null;

        if (!this.limits && !this.quoteCoverages) {
            this.log_error('Received a referred quote but no limits or coverages were supplied.', __location);
            return this.return_error('error', `Could not locate the limits or coverages in the quote returned from the carrier.`);
        }

        if (premiumAmount) {
            this.amount = premiumAmount;
        }
        if (quoteNumber) {
            this.number = quoteNumber;
        }
        if (quoteLetter) {
            this.quote_letter = {
                content_type: quoteLetterMimeType ? quoteLetterMimeType : "application/base64",
                data: quoteLetter,
                file_name: `${this.insurer.name}_ ${this.policy.type}_quote_letter.pdf`
            };
        }

        const message = `Referred${premiumAmount ? ` with premium $${premiumAmount}` : ""}`;
        this.log += `<br>${message}<br><br>\n`;
        this.log_info(message, __location);

        return this.return_result('referred');
    }

    /**
     * Returns a quote object for a 'quoted' quote
     *
     * NOTE: limits will "eventually" be deprecated and replaced by coverages
     *
     * @param {string} quoteNumber - The quote's number for the given insurer (optional, but encouraged)
     * @param {array<object>} limits - The limits parsed from the quote (optional if coverages is supplied)
     * @param {int} premiumAmount - The premium amount
     * @param {string} quoteLetter - The quote letter (optional)
     * @param {int} quoteLetterMimeType - Quote letter mime type (optional, default = "application/base64")
     * @param {array<object>} quoteCoverages - The insurer quote coverages parsed from the quote (optional if limits is supplied)
     * @returns {object} - An object containing the quote information
     */
    async client_quoted(quoteNumber, limits = {}, premiumAmount, quoteLetter = null, quoteLetterMimeType = null, quoteCoverages = []) {
        this.limits = limits && Object.keys(limits).length > 0 ? limits : null;
        this.quoteCoverages = quoteCoverages && quoteCoverages.length > 0 ? quoteCoverages : null;

        if (!this.limits && !this.quoteCoverages) {
            this.log_error('Received a referred quote but no limits or coverages were supplied.', __location);
            return this.return_error('error', `Could not locate the limits or coverages in the quote returned from the carrier.`);
        }

        if (!premiumAmount) {
            this.log_error(`Received a quote but no premium amount for Appid: ${this.app.id} Insurer: ${this.insurer.name}`, __location);
            return this.return_error('error', `Could not locate the limits in the quote returned from the carrier.`);
        }
        this.amount = premiumAmount;

        if (quoteNumber) {
            this.number = quoteNumber;
        }

        if (quoteLetter) {
            this.quote_letter = {
                content_type: quoteLetterMimeType ? quoteLetterMimeType : "application/base64",
                data: quoteLetter,
                file_name: `${this.insurer.name}_${this.policy.type}_quote_letter.pdf`
            };
        }

        const message = `Quoted with premium $${premiumAmount}`;
        this.log += `<br>${message}<br><br>\n`;
        this.log_info(message, __location);

        // Record the quote
        const quoteResp = await this.record_quote(premiumAmount, 'quoted');
        return quoteResp;
    }

    /**
     * Returns a quote object for an 'error' condition
     *
     * @param {string} publicMessage - Message to display to the customer
     * @param {string} location - location of the error (set to __location)
     * @param {object} extraLogData - Data to append to the logging message
     * @returns {object} - An object containing the quote information
     */
    async client_error(publicMessage, location, extraLogData = null) {

        // Log the public message
        this.log += `<b>Error:</b> ${publicMessage}<br><br>`;
        this.reasons.push(publicMessage);
        this.log_error(publicMessage, location, extraLogData);

        // Return the error with the customer-facing message
        return this.return_error('error', publicMessage);
    }

    /**
     * Returns a quote object for an auto-declined quote
     *
     * @param {string} location - location of the error (set to __location)
     * @param {object} extraLogData - Data to append to the logging message
     * @returns {object} - An object containing the quote information
     */
    async client_connection_error(location, extraLogData = null) {
        return this.client_error('Could not connect to the insurer\'s servers at this time.', location, extraLogData);
    }

    /**
	 * Generates and returns the proper structure for returning a quote from an integration
	 *
	 * @param {int} amount - The amount of the quote as a whole number
	 * @returns {object} - An object containing the quote information
	 */
    async return_quote(amount) {
        const result = await this.record_quote(amount, 'quoted');
        return result;
    }

    /**
	 * Generates and returns the proper structure for returning an indication from an integration
	 *
	 * @param {int} amount - The amount of the indication as a whole number
	 * @returns {object} - An object containing the indication information
	 */
    async return_indication(amount) {
        const quoteResp = await this.record_quote(amount, 'referred_with_price');
        return quoteResp;
    }

    /**
	 * Generates and returns the proper structure for returning an error from an integration
	 *
	 * @param {string} type - The type of error
	 * @param {string} message - A user friendly description of the error
	 * @returns {object} - An error object
	 */
    async return_error(type, message) {
        log.info(`Appid: ${this.app.id} ${this.insurer.name} returned an error of type ${type} for a ${this.policy.type} policy: ${message}` + __location);

        // If there were reasons, make sure we write them to the log
        if (this.reasons.length > 0) {
            this.reasons.forEach((reason) => {
                log.verbose(reason);
            });
        }

        // Record this quote
        const quoteResp = await this.record_quote(null, type);
        return quoteResp;
    }

    /**
	 * Returns an object of the limits for this policy with the propery as the limit description and the value as the amount
	 *
	 * @returns {object} - The limit information
	 */
    async returnLimits() {
        const rtn = {};

        // If there is no limits data, just return an empty object
        if (!Object.keys(this.limits).length) {
            return rtn;
        }

        // Get the limit descriptions from the database
        // TODO USE BO
        const result = await db.query(`SELECT * FROM \`#__limits\` WHERE \`id\` IN (${Object.keys(this.limits).join(',')}) ORDER BY description ASC;`).catch(function(err) {
            return err;
        });

        // Loop through the results and build the response
        result.forEach((limitInfo) => {
            rtn[limitInfo.description] = this.limits[limitInfo.id];
        });

        return rtn;
    }

    /**
	 * Determines which response should be sent, and sends it. This should be called by every insurer integration.
	 *
	 * @param {string} result - The result of the integration. Must be 'declined', 'quoted', 'referred', or 'referred_with_price'
	 * @returns {mixed} - An object containing the response to be sent to the user on success, false on failure
	 */
    return_result(result) {
        // Determine the log messages to show
        const log_messages = {
            autodeclined: 'System Autodeclined',
            declined: 'Application Declined',
            error: 'Integration Error',
            outage: 'Insurer System Outage',
            quoted: 'Quote Recieved',
            referred: 'Application Referred',
            referred_with_price: 'Application Referred With Price',
            acord_emailed: 'Acord Form Emailed'
        };

        // Make sure we have a result
        if (!result) {
            const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Missing argument for return_result(). Must pass in a valid value for result.`;
            log.error(error_message + __location);
            this.reasons.push(error_message);
            return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');
        }

        // Make sure the result is one of the ones we are expecting
        if (!Object.keys(log_messages).includes(result)) {
            // If result is a possible API result from an integration, convert it to the Talage equivalent
            if (Object.keys(this.possible_api_responses).includes(result)) {
                result = this.possible_api_responses[result];
            }
            else {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Invalid value of '${result}' for result passed to return_result(). Result not specified in the insurer integration.`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');
            }

            // Double check: Is the result now what we are expecting
            if (!Object.keys(log_messages).includes(result)) {
                const error_message = `Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Invalid value of '${result}' for result passed to return_result(). Must be a valid value as defined in return_result().`;
                log.error(error_message + __location);
                this.reasons.push(error_message);
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');
            }
        }

        // Check if this was referred, but a price was still provided, and if so, update the status
        if ((result === 'referred' || this.indication) && this.amount) {
            result = 'referred_with_price';
        }

        // If this was quoted, make sure we have an amount
        if ((result === 'quoted' || result === 'referred_with_price') && !this.amount) {
            log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Unable to find quote amount. Response structure may have changed.` + __location);
            this.reasons.push(`${this.insurer.name} ${this.policy.type} Integration Error: Unable to find quote amount. Response structure may have changed.`);
            if (result === 'quoted') {
                result = 'error';
            }
            else {
                result = 'referred';
            }
        }

        // If this was quoted, make sure we have limits
        if (result === 'quoted' || result === 'referred_with_price') {

            // if we're quoted or referred w/ price, AND either both limits are null, or one is null and the other has no limit entries
            if ((!this.limits && !this.quoteCoverages) || 
                (!this.limits && this.quoteCoverages && !this.quoteCoverages.length > 0) ||
                (!this.quoteCoverages && this.limits && !Object.keys(this.limits).length > 0)) 
            {
                log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration Error: Unable to find limits. Response structure may have changed.` + __location);
            }

        }

        // Start the log message
        this.log += `--------======= ${log_messages[result]} =======--------<br><br>`;

        // Log the amount
        if (this.amount) {
            this.log += `Quote: ${this.amount}<br>`;
        }

        // Log the reasons
        if (this.reasons.length > 0) {
            this.log += `The insurer returned the following reasons for why they made this decision:<ul><li>${this.reasons.join('</li><li>')}</li></ul>`;
        }

        // Take the appropriate action
        switch (result) {
            case 'autodeclined':
                return this.return_error('autodeclined', 'This insurer will decline to offer you coverage at this time');

            case 'declined':
                if (this.reasons) {
                    this.reasons.forEach(function(reason) {
                        log.verbose(reason);
                    });
                }
                this.reasons.push('Declined by insurer');
                return this.return_error('declined', `${this.insurer.name} has declined to offer you coverage at this time`);

            case 'error':
                log.error(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Integration returned An Error` + __location);
                if (this.reasons) {
                    //this.reasons.forEach(function(reason) {
                    for(let i = 0; i < this.reasons.length; i++){
                        log.error(`Appid: ${this.app.id} Insurer: ${this.insurer.name} ` + this.reasons[i] + __location);
                    }
                }
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');

            case 'outage':
                log.warn(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Experienced A System Outage At The Time of Quote` + __location);
                if (this.reasons) {
                    this.reasons.forEach(function(reason) {
                        log.verbose(reason);
                    });
                }
                return this.return_error('error', 'Well, that wasn’t supposed to happen, but hang on, we’ll get it figured out quickly and be in touch.');

            case 'quoted':
                log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Returned Quote(s)` + __location);
                return this.return_quote(this.amount);

            case 'referred':
                if (this.reasons) {
                    this.reasons.forEach(function(reason) {
                        log.verbose(reason);
                    });
                }
                return this.return_error('referred', `Appid: ${this.app.id} ${this.insurer.name} needs a little more time to make a decision`);
            case 'acord_emailed':
                return this.return_error('acord_emailed', `Appid: ${this.app.id} ${this.insurer.name} AgencyLocation ${this.app.agencyLocation.id} acord form sent`);
            case 'referred_with_price':
                log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Referred To Underwriting, But Provided An Indication` + __location);
                return this.return_indication(this.amount);

            default:
        }
    }

    /**
	 * Gets a formatted XML string
     *
     * @param {string} str - A string which may or may not be valid XML
     * @returns {string | null} A formatted XML string for valid JSON input, null otherwise
	 */
    get_formatted_xml_string(str) {
        // Format XML to be readable
        let formattedString = '';
        try {
            formattedString = xmlFormatter(str);
        }
        catch (error) {
            return null;
        }
        return formattedString;
    }

    /**
	 * Gets a formatted JSON string
     *
     * @param {string} str - A string which may or may not be valid JSON
     * @returns {string | null} A formatted JSON string for valid JSON input, null otherwise
	 */
    get_formatted_json_string(str) {
        let formattedString = '';
        try {
            formattedString = JSON.stringify(JSON.parse(str), null, 4);
        }
        catch (error) {
            return null;
        }
        return formattedString;
    }

    /**
	 * Sends a request to an insurer over HTTPS
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} data - The data to be sent
	 * @param {object} additional_headers - Additional headers to be sent with the request, one header 'Content-Type' is required, all others are optional
	 * @param {string} method (optional) - The HTTP method to be used (e.g. POST or GET)
     * @param {boolean} log_errors - True if error logging should be handled here, false if error logging is handled in the client
     * @param {boolean} returnResponseOnAllStatusCodes - True if response should be returned (fulfilled) on all HTTP status codes, false if it should reject (default)
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */
    send_request(host, path, data, additional_headers, method, log_errors = true, returnResponseOnAllStatusCodes = false) {
        log.info(`Appid: ${this.app.id} ${this.insurer.name} ${this.policy.type} Sending To ${path}` + __location);
        const start_time = process.hrtime();

        return new Promise((fulfill, reject) => {
            // Determine which method to use
            if (!method) {
                method = data ? 'POST' : 'GET';
            }

            // Check that we have a valid method
            if (![
                'GET',
                'POST',
                'PUT'
            ].includes(method)) {
                const error = new Error(`Appid: ${this.app.id} calling ${this.insurer.name} Invalid method provided to send_request()`);
                log.error(error.message + __location);
                reject(error);
                return;
            }

            // Add a timestamp to the request log
            this.log += `<b>Request started at ${moment().utc().toISOString()}</b><br><br>`;

            // Build the headers
            const headers = {};
            let content_type_found = false;
            if (additional_headers) {
                for (const key in additional_headers) {
                    if (Object.prototype.hasOwnProperty.call(additional_headers, key)) {
                        if (key === 'Content-Type') {
                            content_type_found = true;
                            if (additional_headers[key] === 'application/x-www-form-urlencoded') {
                                // Encode the data
                                const querystring = require('querystring');
                                data = querystring.stringify(data);
                            }
                            let formattedString = data;
                            // Attempt to format it if it is a XML string
                            const formattedXMLString = this.get_formatted_xml_string(data);
                            if (formattedXMLString) {
                                formattedString = formattedXMLString;
                            }
                            else {
                                // Attempt to format it if it is a JSON string
                                const formattedJSONString = this.get_formatted_json_string(data);
                                if (formattedJSONString) {
                                    formattedString = formattedJSONString;
                                }
                            }
                            // Log the request
                            this.log += `--------======= Sending ${additional_headers[key]} =======--------<br><br>`;
                            this.log += `URL: ${host}${path} - ${method}<br><br>`;
                            this.log += `<pre>${htmlentities.encode(formattedString)}</pre><br><br>`;
                        }
                        headers[key] = additional_headers[key];
                    }
                }
            }
            if (!content_type_found) {
                const error = new Error(`Appid: ${this.app.id} calling ${this.insurer.name} No Content-Type header found. The Content-Type header is required for calls to send_request()`);
                log.error(error.message + __location);
                reject(error);
                return;
            }

            // Set the length parameter
            headers['Content-Length'] = data && data.length ? Buffer.byteLength(data) : 0;

            // Set the request options
            const options = {
                agent: false,
                headers: headers,
                hostname: host,
                method: method,
                path: path,
                rejectUnauthorized: false,
                requestCert: true,
                timeout: 180000
            };

            const req = https.request(options, (res) => {
                let rawData = '';
                log.debug("in https response " + __location)
                // Grab each chunk of data
                res.on('data', (d) => {
                    rawData += d;
                });

                res.on('end', () => {
                    // Calculate how long this took
                    this.seconds = process.hrtime(start_time)[0];

                    // Attempt to format the returned data
                    //log.debug(` Appid: ${this.app.id} calling ${this.insurer.name} rawData ${rawData}`)
                    let formattedData = rawData;
                    if (headers['Content-Type'] && headers['Content-Type'].toLowerCase() === 'text/xml') {
                        // Format XML to be readable
                        const formattedXMLData = this.get_formatted_xml_string(rawData);
                        if (formattedXMLData) {
                            formattedData = formattedXMLData;
                        }
                    }
                    else if (headers['Content-Type'] && headers['Content-Type'].toLowerCase() === 'application/json') {
                        // Format JSON to be readable
                        const formattedJSONData = this.get_formatted_json_string(rawData);
                        if (formattedJSONData) {
                            formattedData = formattedJSONData;
                        }
                    }
                    if (res.statusCode >= 200 && res.statusCode <= 299 || returnResponseOnAllStatusCodes) {
                        // Strip AF Group's Quote Letter out of the log
                        formattedData = formattedData.replace(/<com\.afg_Base64PDF>(.*)<\/com\.afg_Base64PDF>/, '<com.afg_Base64PDF>...</com.afg_Base64PDF>');

                        // Strip Employer's Quote Letter out of the log
                        formattedData = formattedData.replace(/<BinData>(.*)<\/BinData>/, '<BinData>...</BinData>');

                        // Strip Acuity's Quote Letter out of the log
                        formattedData = formattedData.replace(/<!\[CDATA.*>/, '<![CDATA[...]]>');

                        this.log += `--------======= Response Appid: ${this.app.id}  =======--------<br><br>`;
                        this.log += `<pre>${htmlentities.encode(formattedData)}</pre><br><br>`;
                        fulfill(rawData);
                    }
                    else{
                        const error = new Error(`Appid: ${this.app.id} insurer request encountered a ${res.statusCode} error`);
                        // Added check - do not log errors if there is a special response case for the client to handle
                        if(log_errors){
                            log.error(error.message + `  Appid: ${this.app.id} calling ${this.insurer.name} ` + __location);
                            log.verbose(rawData);
                            this.log += `--------======= Error Appid: ${this.app.id} calling ${this.insurer.name}  =======--------<br><br>`;
                            this.log += `Status Code: ${res.statusCode} <br>`;
                            this.log += `<pre>${htmlentities.encode(formattedData)}</pre><br><br>`;
                        }
                        error.httpStatusCode = res.statusCode;
                        error.response = rawData;
                        reject(error);
                    }
                });
            });

            req.on('error', (err) => {
                log.error(`Connection to ${this.insurer.name} timedout. error ${err}` + __location);
                this.log += `Connection to ${this.insurer.name} timedout. error ${err} `;
                reject(new Error(`Appid: ${this.app.id} Connection to ${this.insurer.name} terminated. Reason: ${err.code}`));
            });

            if (data) {
                req.write(data);
            }
            req.end();
        });
    }

    /**
	 * Sends an JSON request to this insurer
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} json - The JSON to be sent
	 * @param {object} additional_headers (optional) - Additional headers to be sent with the request
	 * @param {string} method (optional) - The HTTP method to be used
     * @param {boolean} log_errors - True if errors should be logged, false otherwise
     * @param {boolean} returnResponseOnAllStatusCodes - True if response should be returned (fulfilled) on all HTTP status codes, false if it should reject (default)
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */

    send_json_request(host, path, json, additional_headers, method, log_errors = true, returnResponseOnAllStatusCodes = false) {
        return new Promise(async(fulfill, reject) => {
            // If we don't have additional headers, start an object to append
            if (!additional_headers) {
                additional_headers = {};
            }

            // Add in the JSON specific headers
            if (!Object.prototype.hasOwnProperty.call(additional_headers, 'Content-Type')) {
                additional_headers['Content-Type'] = 'application/json';
            }
            additional_headers.accept = 'application/json';

            // Send the request
            await this.send_request(host, path, json, additional_headers, method, log_errors, returnResponseOnAllStatusCodes).
                then((result) => {
                    fulfill(JSON.parse(result));
                }).
                catch((error) => {
                    reject(error);
                });
        });
    }

    /**
	 * Sends an XML request to this insurer
	 *
	 * @param {string} host - The host name we are sending to (minus the protocol)
	 * @param {string} path - The path at the host name we are sending to (the parts after the /, including the query string, if any)
	 * @param {string} xml - The XML to be sent
	 * @param {object} additional_headers (optional) - Additional headers to be sent with the request
	 * @param {boolean} dumpRawXML (optional) - Dump the raw XML response to the console
     * @param {boolean} returnResponseOnAllStatusCodes - True if response should be returned (fulfilled) on all HTTP status codes, false if it should reject (default)
	 * @returns {Promise.<object, Error>} A promise that returns an object containing the request response if resolved, or an Error if rejected
	 */
    async send_xml_request(host, path, xml, additional_headers, dumpRawXML = false, returnResponseOnAllStatusCodes = false) {
        // return new Promise(async(fulfill, reject) => {
        // If we don't have additional headers, start an object to append
        if (!additional_headers) {
            additional_headers = {};
        }

        // Add in the content length header
        additional_headers['Content-Length'] = Buffer.byteLength(xml);

        // Add in the XML specific headers
        if (!Object.prototype.hasOwnProperty.call(additional_headers, 'Content-Type')) {
            additional_headers['Content-Type'] = 'text/xml';
        }

        // Send the request
        let raw_data = null;
        try {
            raw_data = await this.send_request(host, path, xml, additional_headers, 'POST', true, returnResponseOnAllStatusCodes);
        }
        catch (error) {
            log.error(`Appid: ${this.app.id} calling ${this.insurer.name} Integration send_request error: ${error}` + __location);
            // reject(error);
            throw error;
        }
        // Convert the data to a string
        const str_data = raw_data.toString();

        if (dumpRawXML) {
            // eslint-disable-next-line no-console
            console.log(xmlFormatter(str_data, {collapseContent: true}));
        }

        // Convert the response to XML
        let result = null;
        try {
            result = xmlToObj(str_data);
        }
        catch (error) {
            const errData = {
                // eslint-disable-line prefer-promise-reject-errors
                message: 'Response from API was not XML',
                raw: str_data
            };
            throw new Error(JSON.stringify(errData));
        }
        return result;
    }

    /**
	 * Determines whether or not this insurer supports all class codes in this application
	 *
	 * @returns {Promise.<boolean>} A promise that returns an true if the insurer supports the activity code and populates them, false otherwise
	 */
    _insurer_supports_activity_codes() {
        return new Promise(async(fulfill) => {
            // eslint-disable-next-line prefer-const
            let territoryList = []
            // eslint-disable-next-line prefer-const
            let activityCodeArray = [];
            this.app.business.locations.forEach(function(location) {
                location.activity_codes.forEach(function(activity_code) {
                    if(!activityCodeArray.includes(activity_code.id)){
                        activityCodeArray.push(activity_code.id)
                    }
                    if(!territoryList.includes(activity_code.id)){
                        territoryList.push(location.territory)
                    }
                });
            });
            let fullFillValue = false;
            const InsurerActivityCodeModel = require('mongoose').model('InsurerActivityCode');
            const policyEffectiveDate = moment(this.policy.effective_date).format(db.dbTimeFormat());
            const activityCodeQuery = {
                insurerId: this.insurer.id,
                talageActivityCodeIdList: {$in: activityCodeArray},
                territoryList: {$in: territoryList},
                effectiveDate: {$lte: policyEffectiveDate},
                expirationDate: {$gte: policyEffectiveDate},
                active: true
            }
            try{
                const insurerActivityCodeList = await InsurerActivityCodeModel.find(activityCodeQuery)
                let missingMap = false;
                const appId = this.app.id;
                const insurerId = this.insurer.id;
                const requiresInsurerActivityClassCodes = this.requiresInsurerActivityClassCodes
                // eslint-disable-next-line prefer-const
                let reasons = this.reasons;
                // eslint-disable-next-line prefer-const
                let insurer_wc_codes = this.insurer_wc_codes
                //backward compatible populate this.insurer_wc_codes
                this.app.business.locations.forEach(function(location) {
                    location.activity_codes.forEach(function(activity_code) {
                    //find making insurerActivityCodeList doc
                        try{
                            const insurerActivityCode = insurerActivityCodeList.find((iac) => iac.talageActivityCodeIdList.includes(activity_code.id) && iac.territoryList.includes(location.territory));
                            if(insurerActivityCode){
                                insurer_wc_codes[location.territory + activity_code.id] = insurerActivityCode.code + (insurerActivityCode.sub ? insurerActivityCode.sub : '');
                            }
                            else if (requiresInsurerActivityClassCodes){
                                reasons.push("Insurer activity class codes were not found for all activities in the application.");
                                log.warn(`AppId: ${appId} InsurerId: ${insurerId} _insurer_supports_activity_codes failed on application. ${location.territory} ${activity_code.id} query ${JSON.stringify(activityCodeQuery)} ` + __location);
                                missingMap = true;
                            }
                        }
                        catch(err){
                            log.error(`AppId: ${appId} InsurerId: ${insurerId} _insurer_supports_activity_codes error ${err}` + __location);
                        }
                    });
                });
                if(missingMap === false){
                    fullFillValue = true;
                }
            }
            catch(err){
                log.warn(`Appid: ${this.app.id} Error checking ActivtyCodes for ${this.insurer.name}:${this.insurer.id} and ${this.app.applicationDocData.mailingState}` + __location);
                fullFillValue = false;
            }
            fulfill(fullFillValue);
        });
    }

    /**
	 * Determines whether or not this insurer supports all industry codes in this application
     *
	 * @returns {Promise.<boolean>} A promise that returns an true if the insurer supports the industry code and it has been populated, false otherwise
	 */
    _insurer_supports_industry_codes() {
        return new Promise(async(fulfill) => {
            const InsurerIndustryCodeModel = require('mongoose').model('InsurerIndustryCode');
            const policyEffectiveDate = moment(this.policy.effective_date).format(db.dbTimeFormat());
            // eslint-disable-next-line prefer-const
            let industryQuery = {
                insurerId: this.insurer.id,
                talageIndustryCodeIdList: this.app.applicationDocData.industryCode,
                territoryList: this.app.applicationDocData.mailingState,
                effectiveDate: {$lte: policyEffectiveDate},
                expirationDate: {$gte: policyEffectiveDate},
                active: true
            }
            if (this.requiresProductPolicyTypeFilter && this.policyTypeFilter) {
                // eslint-disable-next-line prefer-const
                let orParamList = [];
                const policyTypeCheck = {policyTypeList: this.policyTypeFilter};
                //const policyTypeNullCheck = {policyTypeList: null}
                const noPolicyTypeCheck = {'policyTypeList.0': {$exists: false}};
                orParamList.push(policyTypeCheck)
                orParamList.push(noPolicyTypeCheck)
                industryQuery.$or = orParamList;
            }
            // eslint-disable-next-line prefer-const
            try{
                const insurerIndustryCodeList = await InsurerIndustryCodeModel.find(industryQuery).lean()
                if(insurerIndustryCodeList && insurerIndustryCodeList.length > 0){
                    const insurerIndustryCode = insurerIndustryCodeList[0];
                    this.insurerIndustryCode = insurerIndustryCode;
                    this.industry_code = JSON.parse(JSON.stringify(insurerIndustryCode));
                }
                else {
                    this.industry_code = null;
                    if (this.requiresInsurerIndustryCodes) {
                        this.reasons.push("An insurer industry class code was not found for the given industry and territory.");
                        log.warn(`AppId: ${this.app.id} InsurerId: ${this.insurer.id} _insurer_supports_industry_codes required insurer mapping for this industry code was not found. query ${JSON.stringify(industryQuery)} ` + __location);
                        fulfill(false);
                        return;
                    }
                }
                // If insurer industry codes are not required, then still retrieve the industry code for the integration to use.
               
                // const sql = `
                //     SELECT ic.id, ic.description, ic.cgl, ic.sic, ic.hiscox, ic.naics, ic.iso 
                //     FROM clw_talage_industry_codes AS ic 
                //     WHERE ic.id = ${this.app.applicationDocData.industryCode};
                // `;
                // let hadError = false;
                // const result = await db.query(sql).catch((error) => {
                //     log.error(`AppId: ${this.app.id} InsurerId: ${this.insurer.id} Could not retrieve industry codes: ${error} ${__location}`);
                //     hadError = true;
                // });
                // if (hadError) {
                //     // Query error
                //     fulfill(false);
                //     return;
                // }
                try{
                    const IndustryCodeBO = global.requireShared('models/IndustryCode-BO.js');
                    const industryCodeBO = new IndustryCodeBO();
                    const industryCodeJson = await industryCodeBO.getById(this.app.applicationDocData.industryCode);
                    if(industryCodeJson){
                        if(this.industry_code){
                            //backward compatible with old multi-table query.
                            // eslint-disable-next-line array-element-newline
                            const propsToCopy = ['description','cgl', 'sic', 'hiscox', 'naics','iso'];
                            // eslint-disable-next-line guard-for-in
                            this.industry_code.id = industryCodeJson.industryCodeId;
                            for(const prop in industryCodeJson){
                                if(propsToCopy.indexOf(prop) > -1){
                                    this.insurerIndustryCode[prop] = industryCodeJson[prop];
                                    this.industry_code[prop] = industryCodeJson[prop];
                                }
                            }
                        }
                        else {
                            this.industry_code = industryCodeJson;
                            this.industry_code.id = industryCodeJson.industryCodeId;
                        }
                    }
                }
                catch(err){
                    log.error("Error getting industryCodeBO " + err + __location);
                }
                fulfill(true);
            }
            catch(err){
                log.warn(`Appid: ${this.app.id} Error checking Industry_code for ${this.insurer.name}:${this.insurer.id} and ${this.app.applicationDocData.mailingState} error: ${err}` + __location);
                fulfill(false)
            }
            return;
        });
    }
};